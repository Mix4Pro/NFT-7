"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2572],{62922:function(t,r,e){e.r(r),e.d(r,{Contract:function(){return ee},DefaultProtocol:function(){return m},JSONParseError:function(){return L},MacroError:function(){return y},MichelineParseError:function(){return D},MichelsonError:function(){return lt},MichelsonInstructionError:function(){return Dr},MichelsonTypeError:function(){return pt},MichelsonValidationError:function(){return Nt},Parser:function(){return F},ProtoGreaterOfEqual:function(){return d},ProtoInferiorTo:function(){return w},Protocol:function(){return g},VERSION:function(){return oe},assertContractValid:function(){return Yr},assertDataListIfAny:function(){return ir},assertDataValid:function(){return Wr},assertMichelsonBigMapStorableType:function(){return Vt},assertMichelsonComparableType:function(){return Ht},assertMichelsonContract:function(){return Zt},assertMichelsonData:function(){return Qt},assertMichelsonInstruction:function(){return Ft},assertMichelsonPackableType:function(){return Bt},assertMichelsonPassableType:function(){return jt},assertMichelsonPushableType:function(){return Gt},assertMichelsonStorableType:function(){return Jt},assertMichelsonType:function(){return Wt},assertTypeAnnotationsValid:function(){return Kr},assertTypesEqual:function(){return Qr},assertViewNameValid:function(){return Yt},contractEntryPoint:function(){return Vr},contractEntryPoints:function(){return zr},contractSection:function(){return Gr},contractViews:function(){return Jr},decodeAddressBytes:function(){return Nr},decodePublicKeyBytes:function(){return Rr},decodePublicKeyHashBytes:function(){return $r},dummyContract:function(){return ne},emitMicheline:function(){return j},formatError:function(){return ae},formatStack:function(){return ie},functionType:function(){return qr},instructionIDs:function(){return xt},isContractValid:function(){return Xr},isDataValid:function(){return te},isInstruction:function(){return nr},isMichelsonCode:function(){return rr},isMichelsonData:function(){return tr},isMichelsonError:function(){return ut},isMichelsonScript:function(){return Xt},isMichelsonType:function(){return er},isTypeAnnotationsValid:function(){return Zr},isTypeEqual:function(){return re},packData:function(){return Tr},packDataBytes:function(){return Ir},refContract:function(){return f},sourceReference:function(){return n},traceDumpFunc:function(){return se},unpackData:function(){return Or},unpackDataBytes:function(){return Cr}});const n=Symbol("source_reference");class i extends Error{constructor(t,r,e){super(e),this.src=t,this.idx=r,Object.setPrototypeOf(this,i.prototype)}}var s;!function(t){t[t.Comment=0]="Comment",t[t.Number=1]="Number",t[t.String=2]="String",t[t.Bytes=3]="Bytes",t[t.Ident=4]="Ident"}(s||(s={}));const a=new RegExp("\\s"),o=new RegExp("[:@%_A-Za-z]"),c=new RegExp("[@%_\\.A-Za-z0-9]"),l=new RegExp("[0-9]"),u=new RegExp("[0-9a-fA-F]");function*p(t,r=!1){let e=0;for(;e<t.length;){for(;e<t.length&&a.test(t[e]);)e++;if(e===t.length)return;const n=t[e],p=e;if(o.test(n)){for(e++;e<t.length&&c.test(t[e]);)e++;yield{t:s.Ident,v:t.slice(p,e),first:p,last:e}}else if(t.length-e>1&&"0x"===t.substr(e,2)){for(e+=2;e<t.length&&u.test(t[e]);)e++;if(0!==(e-p&1))throw new i(t,e,"Bytes literal length is expected to be power of two");yield{t:s.Bytes,v:t.slice(p,e),first:p,last:e}}else if(l.test(n)||"-"===n){"-"===n&&e++;const r=e;for(;e<t.length&&l.test(t[e]);)e++;if(r===e)throw new i(t,e,"Number literal is too short");yield{t:s.Number,v:t.slice(p,e),first:p,last:e}}else if('"'===n){e++;let r=!1;for(;e<t.length&&(r||'"'!==t[e]);e++)r=!r&&"\\"===t[e];if(e===t.length)throw new i(t,e,"Unterminated string literal");e++,yield{t:s.String,v:t.slice(p,e),first:p,last:e}}else if("#"===n){for(e++;e<t.length&&"\n"!==t[e];)e++;r&&(yield{t:s.Comment,v:t.slice(p,e),first:p,last:e})}else if(t.length-e>1&&"/*"===t.substr(e,2)){for(e+=2;e<t.length&&!(t.length-e>1&&"*/"===t.substr(e,2));)e++;if(e===t.length)throw new i(t,e,"Unterminated C style comment");e+=2,r&&(yield{t:s.Comment,v:t.slice(p,e),first:p,last:e})}else{if("("!==n&&")"!==n&&"{"!==n&&"}"!==n&&";"!==n)throw new i(t,e,`Invalid character at offset ${e}: \`${n}'`);e++,yield{t:n,v:n,first:p,last:e}}}}const f=Symbol("ref_contract");var g;!function(t){t.Ps9mPmXa="Ps9mPmXaRzmzk35gbAYNCAw6UXdE2qoABTHbN2oEEc1qM7CwT9P",t.PtCJ7pwo="PtCJ7pwoxe8JasnHY8YonnLYjcVHmhiARPJvqcC6VfHT5s8k8sY",t.PsYLVpVv="PsYLVpVvgbLhAhoqAkMFUo6gudkJ9weNXhUYCiLDzcUpFpkk8Wt",t.PsddFKi3="PsddFKi32cMJ2qPjf43Qv5GDWLDPZb3T3bF6fLKiF5HtvHNU7aP",t.Pt24m4xi="Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd",t.PsBABY5H="PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU",t.PsBabyM1="PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS",t.PsCARTHA="PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb",t.PsDELPH1="PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo",t.PtEdoTez="PtEdoTezd3RHSC31mpxxo1npxFjoWWcFgQtxapi51Z8TLu6v6Uq",t.PtEdo2Zk="PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA",t.PsFLoren="PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i",t.PsFLorena="PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i",t.PtGRANAD="PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV",t.PtGRANADs="PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV",t.PtHangzH="PtHangzHogokSuiMHemCuowEavgYTP8J5qQ9fQS793MHYFpCY3r",t.PtHangz2="PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx",t.PsiThaCa="PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP",t.Psithaca2="Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A",t.PtJakarta="PtJakartaiDz69SfDDLXJSiuZqTSeSKRDbKVZC8MNzJnvRjvnGw",t.ProtoALpha="ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK"}(g||(g={}));const m=g.Psithaca2,h={Ps9mPmXaRzmzk35gbAYNCAw6UXdE2qoABTHbN2oEEc1qM7CwT9P:0,PtCJ7pwoxe8JasnHY8YonnLYjcVHmhiARPJvqcC6VfHT5s8k8sY:1,PsYLVpVvgbLhAhoqAkMFUo6gudkJ9weNXhUYCiLDzcUpFpkk8Wt:2,PsddFKi32cMJ2qPjf43Qv5GDWLDPZb3T3bF6fLKiF5HtvHNU7aP:3,Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd:4,PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU:5,PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS:5,PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb:6,PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo:7,PtEdoTezd3RHSC31mpxxo1npxFjoWWcFgQtxapi51Z8TLu6v6Uq:8,PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA:8,PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i:9,PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV:10,PtHangzHogokSuiMHemCuowEavgYTP8J5qQ9fQS793MHYFpCY3r:11,PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx:11,PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP:12,Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A:12,PtJakartaiDz69SfDDLXJSiuZqTSeSKRDbKVZC8MNzJnvRjvnGw:13,ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK:13};function d(t,r){return h[t]>=h[r]}function w(t,r){return h[t]<h[r]}class y extends Error{constructor(t,r){super(r),this.prim=t,Object.setPrototypeOf(this,y.prototype)}}function b(t,r){var e,n;if(0===r&&void 0===t.args||(null===(e=t.args)||void 0===e?void 0:e.length)===r)return!0;throw new y(t,`macro ${t.prim} expects ${r} arguments, was given ${null===(n=t.args)||void 0===n?void 0:n.length}`)}function E(t){if(void 0===t.annots)return!0;throw new y(t,`unexpected annotation on macro ${t.prim}: ${t.annots}`)}function v(t,r){if("int"in r)return!0;throw new y(t,`macro ${t.prim} expects int argument`)}function P(t,r,e,n){let i=0,s=0;const a=[null,null];let o;if(i===r.length)throw new y(t,`unexpected end: ${t.prim}`);let c,l=r[i++];switch(l){case"P":{const{r:a,n:c,an:l}=P(t,r.slice(i),e.slice(s),n);o=a,i+=c,s+=l;break}case"A":s!==e.length&&(a[0]=e[s++]);break;default:throw new y(t,`${t.prim}: unexpected character: ${l}`)}if(i===r.length)throw new y(t,`unexpected end: ${t.prim}`);switch(l=r[i++],l){case"P":{const{r:a,n:o,an:l}=P(t,r.slice(i),e.slice(s),n);c=a.map((([t,r])=>[t+1,r])),i+=o,s+=l;break}case"I":s!==e.length&&(a[1]=e[s++]);break;default:throw new y(t,`${t.prim}: unexpected character: ${l}`)}return{r:n(o,c,[0,a]),n:i,an:s}}function A(t,r,e,n){const i=r[0];switch(i){case"A":return r.length>1?[{prim:"DUP"},{prim:"DIP",args:[[{prim:"CAR",annots:["@%%"]},A(t,r.slice(1),[],n)]]},{prim:"CDR",annots:["@%%"]},{prim:"SWAP"},{prim:"PAIR",annots:["%@","%@",...e]}]:n.a;case"D":return r.length>1?[{prim:"DUP"},{prim:"DIP",args:[[{prim:"CDR",annots:["@%%"]},A(t,r.slice(1),[],n)]]},{prim:"CAR",annots:["@%%"]},{prim:"PAIR",annots:["%@","%@",...e]}]:n.d;default:throw new y(t,`${t.prim}: unexpected character: ${i}`)}}function S(t,r){let e=t.length;for(;e>0&&t[e-1]===r;)e--;return t.slice(0,e)}function T(t){const r=[],e=[];if(void 0!==t)for(const n of t)(0!==n.length&&"%"===n[0]?r:e).push(n);return{fields:r,rest:e}}function I({prim:t,annots:r,args:e}){return Object.assign(Object.assign({prim:t},r&&{annots:r}),e&&{args:e})}const _=/^P[PAI]{3,}R$/,x=/^UNP[PAI]{2,}R$/,O=/^C[AD]{2,}R$/,C=/^SET_C[AD]+R$/,N=/^MAP_C[AD]+R$/,$=/^DI{2,}P$/,R=/^DU+P$/;class D extends Error{constructor(t,r){super(r),this.token=t,Object.setPrototypeOf(this,D.prototype)}}class L extends Error{constructor(t,r){super(r),this.node=t,Object.setPrototypeOf(this,L.prototype)}}const k=new D(null,"Unexpected EOF");function U(t){return t.t===s.Ident&&("@"===t.v[0]||"%"===t.v[0]||":"===t.v[0])}const M=new RegExp("^-?[0-9]+$"),K=new RegExp("^([0-9a-fA-F]{2})*$");class F{constructor(t){this.opt=t}expand(t){var r,e,i;if(void 0!==(null===(r=this.opt)||void 0===r?void 0:r.expandGlobalConstant)&&"constant"===t.prim){const r=function(t,r){return void 0!==t.args&&1===t.args.length&&"string"in t.args[0]&&t.args[0].string in r?r[t.args[0].string]:t}(t,this.opt.expandGlobalConstant);return r!==t&&(r[n]=Object.assign(Object.assign({},t[n]||{first:0,last:0}),{globalConstant:t})),r}if(void 0===(null===(e=this.opt)||void 0===e?void 0:e.expandMacros)||(null===(i=this.opt)||void 0===i?void 0:i.expandMacros)){const r=function(t,r){const e=(null===r||void 0===r?void 0:r.protocol)||m;function n(t){return void 0!==t?[{prim:"RENAME",annots:t}]:[]}switch(t.prim){case"CMPEQ":case"CMPNEQ":case"CMPLT":case"CMPGT":case"CMPLE":case"CMPGE":if(b(t,0))return[{prim:"COMPARE"},I({prim:t.prim.slice(3),annots:t.annots})];break;case"IFEQ":case"IFNEQ":case"IFLT":case"IFGT":case"IFLE":case"IFGE":if(b(t,2))return[{prim:t.prim.slice(2)},I({prim:"IF",annots:t.annots,args:t.args})];break;case"IFCMPEQ":case"IFCMPNEQ":case"IFCMPLT":case"IFCMPGT":case"IFCMPLE":case"IFCMPGE":if(b(t,2))return[{prim:"COMPARE"},{prim:t.prim.slice(5)},I({prim:"IF",annots:t.annots,args:t.args})];break;case"FAIL":if(b(t,0)&&E(t))return[{prim:"UNIT"},{prim:"FAILWITH"}];break;case"ASSERT":if(b(t,0)&&E(t))return[{prim:"IF",args:[[],[[{prim:"UNIT"},{prim:"FAILWITH"}]]]}];break;case"ASSERT_EQ":case"ASSERT_NEQ":case"ASSERT_LT":case"ASSERT_GT":case"ASSERT_LE":case"ASSERT_GE":if(b(t,0)&&E(t))return[{prim:t.prim.slice(7)},{prim:"IF",args:[[],[[{prim:"UNIT"},{prim:"FAILWITH"}]]]}];break;case"ASSERT_CMPEQ":case"ASSERT_CMPNEQ":case"ASSERT_CMPLT":case"ASSERT_CMPGT":case"ASSERT_CMPLE":case"ASSERT_CMPGE":if(b(t,0)&&E(t))return[[{prim:"COMPARE"},{prim:t.prim.slice(10)}],{prim:"IF",args:[[],[[{prim:"UNIT"},{prim:"FAILWITH"}]]]}];break;case"ASSERT_NONE":if(b(t,0)&&E(t))return[{prim:"IF_NONE",args:[[],[[{prim:"UNIT"},{prim:"FAILWITH"}]]]}];break;case"ASSERT_SOME":if(b(t,0))return[{prim:"IF_NONE",args:[[[{prim:"UNIT"},{prim:"FAILWITH"}]],n(t.annots)]}];break;case"ASSERT_LEFT":if(b(t,0))return[{prim:"IF_LEFT",args:[n(t.annots),[[{prim:"UNIT"},{prim:"FAILWITH"}]]]}];break;case"ASSERT_RIGHT":if(b(t,0))return[{prim:"IF_LEFT",args:[[[{prim:"UNIT"},{prim:"FAILWITH"}]],n(t.annots)]}];break;case"IF_SOME":if(b(t,2))return[I({prim:"IF_NONE",annots:t.annots,args:[t.args[1],t.args[0]]})];break;case"IF_RIGHT":if(b(t,2))return[I({prim:"IF_LEFT",annots:t.annots,args:[t.args[1],t.args[0]]})];break;case"CAR":case"CDR":if(void 0===t.args)return t;if(b(t,1)&&v(t,t.args[0])){const r=parseInt(t.args[0].int,10);return I({prim:"GET",args:[{int:"CAR"===t.prim?String(2*r+1):String(2*r)}],annots:t.annots})}}if(_.test(t.prim)&&b(t,0)){const{fields:r,rest:e}=T(t.annots),{r:n}=P(t,t.prim.slice(1),r,((t,r,e)=>[...t||[],...r||[],e]));return n.map((([t,r],i)=>{const s=[...S(r,null).map((t=>null===t?"%":t)),...0===t&&i===n.length-1?e:[]],a=I({prim:"PAIR",annots:0!==s.length?s:void 0});return 0===t?a:{prim:"DIP",args:1===t?[[a]]:[{int:String(t)},[a]]}}))}if(x.test(t.prim)){if(w(e,g.PtEdo2Zk)&&b(t,0)){const{r:r}=P(t,t.prim.slice(3),t.annots||[],((t,r,e)=>[e,...r||[],...t||[]]));return r.map((([t,r])=>{const e=[{prim:"DUP"},I({prim:"CAR",annots:null!==r[0]?[r[0]]:void 0}),{prim:"DIP",args:[[I({prim:"CDR",annots:null!==r[1]?[r[1]]:void 0})]]}];return 0===t?e:{prim:"DIP",args:1===t?[[e]]:[{int:String(t)},[e]]}}))}if("UNPAIR"===t.prim)return t;if(b(t,0)){const{r:r}=P(t,t.prim.slice(3),[],((t,r,e)=>[e,...r||[],...t||[]]));return r.map((([t])=>{const r=I({prim:"UNPAIR"});return 0===t?r:{prim:"DIP",args:1===t?[[r]]:[{int:String(t)},[r]]}}))}}if(O.test(t.prim)&&b(t,0)){const r=[...t.prim.slice(1,t.prim.length-1)];return r.map(((e,n)=>{const i=n===r.length-1?t.annots:void 0;switch(e){case"A":return I({prim:"CAR",annots:i});case"D":return I({prim:"CDR",annots:i});default:throw new y(t,`unexpected character: ${e}`)}}))}if(C.test(t.prim)&&b(t,0)){const{fields:r,rest:e}=T(t.annots);if(r.length>1)throw new y(t,`unexpected annotation on macro ${t.prim}: ${r}`);const n=0!==r.length?{a:[{prim:"DUP"},{prim:"CAR",annots:r},{prim:"DROP"},{prim:"CDR",annots:["@%%"]},{prim:"SWAP"},{prim:"PAIR",annots:[r[0],"%@"]}],d:[{prim:"DUP"},{prim:"CDR",annots:r},{prim:"DROP"},{prim:"CAR",annots:["@%%"]},{prim:"PAIR",annots:["%@",r[0]]}]}:{a:[{prim:"CDR",annots:["@%%"]},{prim:"SWAP"},{prim:"PAIR",annots:["%","%@"]}],d:[{prim:"CAR",annots:["@%%"]},{prim:"PAIR",annots:["%@","%"]}]};return A(t,t.prim.slice(5,t.prim.length-1),e,n)}if(N.test(t.prim)&&b(t,1)){const{fields:r}=T(t.annots);if(r.length>1)throw new y(t,`unexpected annotation on macro ${t.prim}: ${r}`);const e={a:[{prim:"DUP"},{prim:"CDR",annots:["@%%"]},{prim:"DIP",args:[[I({prim:"CAR",annots:0!==r.length?["@"+r[0].slice(1)]:void 0}),t.args[0]]]},{prim:"SWAP"},{prim:"PAIR",annots:[0!==r.length?r[0]:"%","%@"]}],d:[{prim:"DUP"},I({prim:"CDR",annots:0!==r.length?["@"+r[0].slice(1)]:void 0}),t.args[0],{prim:"SWAP"},{prim:"CAR",annots:["@%%"]},{prim:"PAIR",annots:["%@",0!==r.length?r[0]:"%"]}]};return A(t,t.prim.slice(5,t.prim.length-1),[],e)}if($.test(t.prim)&&b(t,1)){let r=0;for(;"I"===t.prim[1+r];)r++;return I({prim:"DIP",args:[{int:String(r)},t.args[0]]})}if(R.test(t.prim)){let r=0;for(;"U"===t.prim[1+r];)r++;if(w(e,g.PtEdo2Zk)){if(1===r){if(void 0===t.args)return t;b(t,1)&&v(t,t.args[0])&&(r=parseInt(t.args[0].int,10))}else b(t,0);return 1===r?[I({prim:"DUP",annots:t.annots})]:2===r?[{prim:"DIP",args:[[I({prim:"DUP",annots:t.annots})]]},{prim:"SWAP"}]:[{prim:"DIP",args:[{int:String(r-1)},[I({prim:"DUP",annots:t.annots})]]},{prim:"DIG",args:[{int:String(r)}]}]}if(1===r)return t;if(b(t,0))return I({prim:"DUP",args:[{int:String(r)}],annots:t.annots})}return t}(t,this.opt);return r!==t&&(r[n]=Object.assign(Object.assign({},t[n]||{first:0,last:0}),{macro:t})),r}return t}parseListExpr(t,r){var e;const i={first:r.first,last:r.last},a="("===r.t;let o;if(a){if(o=t.next(),o.done)throw k;i.last=o.value.last}else o={value:r};if(o.value.t!==s.Ident)throw new D(o.value,`not an identifier: ${o.value.v}`);const c={prim:o.value.v,[n]:i};for(;;){const r=t.next();if(r.done){if(a)throw k;break}if(")"===r.value.t){if(!a)throw new D(r.value,"unexpected closing bracket");i.last=r.value.last;break}if(U(r.value))c.annots=c.annots||[],c.annots.push(r.value.v),i.last=r.value.last;else{c.args=c.args||[];const s=this.parseExpr(t,r.value);i.last=(null===(e=s[n])||void 0===e?void 0:e.last)||i.last,c.args.push(s)}}return this.expand(c)}parseArgs(t,r){var e;const i={first:r.first,last:r.last},s={prim:r.v,[n]:i};for(;;){const r=t.next();if(r.done||"}"===r.value.t||";"===r.value.t)return[s,r];if(U(r.value))i.last=r.value.last,s.annots=s.annots||[],s.annots.push(r.value.v);else{const a=this.parseExpr(t,r.value);i.last=(null===(e=a[n])||void 0===e?void 0:e.last)||i.last,s.args=s.args||[],s.args.push(a)}}}parseSequenceExpr(t,r){var e,i;const a={first:r.first,last:r.last},o=[];o[n]=a;const c="{"===r.t;let l="{"===r.t?null:{value:r};for(;;){if(null===l&&(l=t.next(),l.done||(a.last=l.value.last)),l.done){if(c)throw k;return o}if("}"===l.value.t){if(c)return o;throw new D(l.value,"unexpected closing bracket")}if(l.value.t===s.Ident){const[r,i]=this.parseArgs(t,l.value);a.last=(null===(e=r[n])||void 0===e?void 0:e.last)||a.last,o.push(this.expand(r)),l=i}else{const r=this.parseExpr(t,l.value);a.last=(null===(i=r[n])||void 0===i?void 0:i.last)||a.last,o.push(r),l=null}null===l&&(l=t.next(),l.done||(a.last=l.value.last)),l.done||";"!==l.value.t||(l=null)}}parseExpr(t,r){switch(r.t){case s.Ident:return this.expand({prim:r.v,[n]:{first:r.first,last:r.last}});case s.Number:return{int:r.v,[n]:{first:r.first,last:r.last}};case s.String:return{string:JSON.parse(r.v),[n]:{first:r.first,last:r.last}};case s.Bytes:return{bytes:r.v.slice(2),[n]:{first:r.first,last:r.last}};case"{":return this.parseSequenceExpr(t,r);default:return this.parseListExpr(t,r)}}parseSequence(t){if("string"!==typeof t)throw new TypeError(`string type was expected, got ${typeof t} instead`);const r=p(t),e=r.next();return e.done?null:this.parseSequenceExpr(r,e.value)}parseList(t){if("string"!==typeof t)throw new TypeError(`string type was expected, got ${typeof t} instead`);const r=p(t),e=r.next();return e.done?null:this.parseListExpr(r,e.value)}parseMichelineExpression(t){if("string"!==typeof t)throw new TypeError(`string type was expected, got ${typeof t} instead`);const r=p(t),e=r.next();return e.done?null:this.parseExpr(r,e.value)}parseScript(t){return this.parseSequence(t)}parseData(t){return this.parseList(t)}parseJSON(t){if("object"!==typeof t)throw new TypeError(`object type was expected, got ${typeof t} instead`);if(Array.isArray(t)){const r=[];for(const e of t){if(null===e||"object"!==typeof e)throw new L(e,`unexpected sequence element: ${e}`);r.push(this.parseJSON(e))}return r}if("prim"in t){const r=t;if("string"===typeof r.prim&&(void 0===r.annots||Array.isArray(r.annots))&&(void 0===r.args||Array.isArray(r.args))){const t={prim:r.prim};if(void 0!==r.annots){for(const t of r.annots)if("string"!==typeof t)throw new L(t,`string expected: ${t}`);t.annots=r.annots}if(void 0!==r.args){t.args=[];for(const e of r.args){if(null===e||"object"!==typeof e)throw new L(e,`unexpected argument: ${e}`);t.args.push(this.parseJSON(e))}}return this.expand(t)}throw new L(t,`malformed prim expression: ${t}`)}if("string"in t){if("string"===typeof t.string)return{string:t.string};throw new L(t,`malformed string literal: ${t}`)}if("int"in t){if("string"===typeof t.int&&M.test(t.int))return{int:t.int};throw new L(t,`malformed int literal: ${t}`)}if("bytes"in t){if("string"===typeof t.bytes&&K.test(t.bytes))return{bytes:t.bytes};throw new L(t,`malformed bytes literal: ${t}`)}throw new L(t,`unexpected object: ${t}`)}}class H{constructor(t,r=0){this.opt=t,this.lev=r}indent(t=0){var r;let e="";if(void 0!==(null===(r=this.opt)||void 0===r?void 0:r.indent))for(let n=this.lev+t;n>0;n--)e+=this.opt.indent;return e}get lf(){var t;return(null===(t=this.opt)||void 0===t?void 0:t.newline)||""}get lfsp(){var t;return(null===(t=this.opt)||void 0===t?void 0:t.newline)||" "}down(t){return new H(this.opt,this.lev+t)}}function B(t){return"prim"in t&&(void 0!==t.annots&&0!==t.annots.length||void 0!==t.args&&0!==t.args.length)}function G(t){if(void 0!==t.args)for(const r of t.args)if(Array.isArray(r)||B(r))return!0;return!1}function J(t,r,e){var i;const s=null===(i=t[n])||void 0===i?void 0:i.macro;if(e&&s)return J(s,r,e);if(Array.isArray(t))return function(t,r,e){let n="{"+r.lf,i=t.length;for(const s of t){if(n+=r.indent(1),"prim"in s){if(n+=s.prim,void 0!==s.annots)for(const t of s.annots)n+=" "+t;if(void 0!==s.args){const t=G(s);for(const i of s.args)n+=t?r.lfsp+r.indent(2)+J(i,r.down(2),e):" "+J(i,r,e)}}else n+=J(s,r.down(1),e);n+=i>1?";"+r.lfsp:r.lf,i--}return n+r.indent()+"}"}(t,r,e);if("string"in t)return JSON.stringify(t.string);if("int"in t)return t.int;if("bytes"in t)return"0x"+t.bytes;{if((void 0===t.annots||0===t.annots.length)&&(void 0===t.args||0===t.args.length))return t.prim;let n="("+t.prim;if(void 0!==t.annots)for(const r of t.annots)n+=" "+r;if(void 0!==t.args){const i=G(t);for(const s of t.args)n+=i?r.lfsp+r.indent(1)+J(s,r.down(1),e):" "+J(s,r,e)}return n+")"}}function j(t,r,e=!1){if("object"!==typeof t)throw new TypeError(`object type was expected, got ${typeof t} instead`);return J(t,new H(r),e)}const V=[1779033703,-1150833019,1013904242,-1521486534,1359893119,-1694144372,528734635,1541459225],z=[1116352408,1899447441,-1245643825,-373957723,961987163,1508970993,-1841331548,-1424204075,-670586216,310598401,607225278,1426881987,1925078388,-2132889090,-1680079193,-1046744716,-459576895,-272742522,264347078,604807628,770255983,1249150122,1555081692,1996064986,-1740746414,-1473132947,-1341970488,-1084653625,-958395405,-710438585,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,-2117940946,-1838011259,-1564481375,-1474664885,-1035236496,-949202525,-778901479,-694614492,-200395387,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,-2067236844,-1933114872,-1866530822,-1538233109,-1090935817,-965641998];class Y extends Error{constructor(t){super(t),this.message=t,this.name="Base58DecodingError"}}class W extends Error{constructor(t){super(t),this.message=t,this.name="InvalidMessageError"}}function q(t){const r=(t.length+9)%64,e=0===r?0:64-r;if(t.length>268435455)throw new W(`SHA-256 -- message length is too big: ${t.length}`);const n=t.length<<3,i=[...t,128,...new Array(e).fill(0),0,0,0,0,n>>24&255,n>>16&255,n>>8&255,255&n];function s(t,r){return t>>>r|t<<32-r}const a=[...V],o=new Array(64),c=new Array(8);for(let u=0;u<i.length;u+=64){let t=u,r=0;for(;r<16;)o[r]=i[t]<<24|i[t+1]<<16|i[t+2]<<8|i[t+3],t+=4,r++;for(;r<64;){const t=s(o[r-15],7)^s(o[r-15],18)^o[r-15]>>>3,e=s(o[r-2],17)^s(o[r-2],19)^o[r-2]>>>10;o[r]=(0|e)+o[r-7]+t+o[r-16]|0,r++}for(let e=0;e<8;e++)c[e]=a[e];for(let e=0;e<64;e++){const t=s(c[0],2)^s(c[0],13)^s(c[0],22),r=s(c[4],6)^s(c[4],11)^s(c[4],25),n=c[7]+r+(c[4]&c[5]^~c[4]&c[6])+z[e]+o[e]|0,i=t+(c[0]&c[1]^c[0]&c[2]^c[1]&c[2])|0;c[7]=c[6],c[6]=c[5],c[5]=c[4],c[4]=c[3]+n|0,c[3]=c[2],c[2]=c[1],c[1]=c[0],c[0]=n+i|0}for(let e=0;e<8;e++)a[e]=a[e]+c[e]|0}const l=[];for(const u of a)l.push(u>>24&255),l.push(u>>16&255),l.push(u>>8&255),l.push(255&u);return l}const Q=[0,1,2,3,4,5,6,7,8,-1,-1,-1,-1,-1,-1,-1,9,10,11,12,13,14,15,16,-1,17,18,19,20,21,-1,22,23,24,25,26,27,28,29,30,31,32,-1,-1,-1,-1,-1,-1,33,34,35,36,37,38,39,40,41,42,43,-1,44,45,46,47,48,49,50,51,52,53,54,55,56,57],Z=[0,1,2,3,4,5,6,7,8,16,17,18,19,20,21,22,23,25,26,27,28,29,31,32,33,34,35,36,37,38,39,40,41,48,49,50,51,52,53,54,55,56,57,58,60,61,62,63,64,65,66,67,68,69,70,71,72,73];function X(t,r){const e=t.charCodeAt(r)-49;if(e>=Q.length||-1===Q[e])throw new Y(`Unexpected character at position ${r}: ${t[r]}`);return Q[e]}function tt(t){const r=function(t){const r=[];let e=0;for(;e<t.length&&0===X(t,e);)e++;let n=e;for(;e<t.length;){let n=X(t,e++),i=0;for(;0!==n||i<r.length;){const t=58*(r[i]||0)+n;r[i++]=t%256,n=Math.floor(t/256)}}for(;n-- >0;)r.push(0);return r.reverse()}(t);if(r.length<4)throw new Y(`Data is too short ${r.length}`);const e=r.slice(0,r.length-4),n=r.slice(r.length-4),i=q(q(e));if(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==i[3])throw new Y("Invalid checksum");return e}function rt(t){const r=q(q(t));return function(t){const r=[];let e=0;for(;e<t.length&&0===t[e];)e++;let n=e;for(;e<t.length;){let n=t[e++],i=0;for(;0!==n||i<r.length;){const t=256*(r[i]||0)+n;r[i++]=t%58,n=Math.floor(t/58)}}for(;n-- >0;)r.push(0);return r.reverse(),String.fromCharCode(...r.map((t=>Z[t]+49)))}([...t,...r.slice(0,4)])}class et extends Error{constructor(t){super(t),this.message=t,this.name="InvalidContractError"}}class nt extends Error{constructor(t){super(t),this.message=t,this.name="InvalidTypeExpressionError"}}class it extends Error{constructor(t){super(t),this.message=t,this.name="InvalidDataExpressionError"}}class st extends Error{constructor(t){super(`Contract has no entrypoint named: '${t}'`),this.entrypoint=t,this.name="InvalidEntrypointError"}}class at extends Error{constructor(t){super(t),this.message=t,this.name="TezosIdEncodeError"}}class ot extends Error{constructor(t){super(t),this.message=t,this.name="LongIntegerError"}}class ct extends Error{constructor(t){super(`Unable to parse hex byte: ${t}`),this.hexByte=t,this.name="HexParseError"}}class lt extends Error{constructor(t,r){super(r),this.val=t,Object.setPrototypeOf(this,lt.prototype)}}function ut(t){return t instanceof lt}class pt extends lt{constructor(t,r,e){super(t,e),void 0!==r&&(this.data=r),Object.setPrototypeOf(this,pt.prototype)}}class ft{constructor(t){if(this.neg=!1,this.buf=[],void 0!==t)if("string"===typeof t)for(let r=0;r<t.length;r++){const e=t.charCodeAt(r);if(0===r&&45===e)this.neg=!0;else{if(e<48||e>57)throw new ot(`unexpected character in integer constant: ${t[r]}`);this.append(e-48)}}else t<0?(this.neg=!0,this.append(-t)):this.append(t)}append(t){let r=0;for(;0!==t||r<this.buf.length;){const e=10*(this.buf[r]||0)+t;this.buf[r++]=e%256,t=Math.floor(e/256)}}cmp(t){if(this.neg!==t.neg)return(t.neg?1:0)-(this.neg?1:0);{let r=0;if(this.buf.length!==t.buf.length)r=this.buf.length<t.buf.length?-1:1;else if(0!==this.buf.length){let e=t.buf.length-1;for(;e>=0&&this.buf[e]===t.buf[e];)e--;r=e<0?0:this.buf[e]<t.buf[e]?-1:1}return this.neg?0===r?0:-r:r}}get sign(){return 0===this.buf.length?0:this.neg?-1:1}}function gt(t){const r=[];for(let e=0;e<t.length;e+=2){const n=parseInt(t.slice(e,e+2),16);if(Number.isNaN(n))return null;r.push(n)}return r}function mt(t){try{return new ft(t),!0}catch(r){return!1}}function ht(t){try{return new ft(t).sign>=0}catch(r){return!1}}const dt=/^(@%|@%%|%@|[@:%]([_0-9a-zA-Z][_0-9a-zA-Z.%@]*)?)$/;function wt(t,r){if(Array.isArray(t))return{};let e,n,i;if(void 0!==t.annots)for(const s of t.annots)if(0!==s.length){if(!dt.test(s)||!(null===r||void 0===r?void 0:r.specialVar)&&("@%"===s||"@%%"===s)||!(null===r||void 0===r?void 0:r.specialFields)&&"%@"===s)throw new lt(t,`${t.prim}: unexpected annotation: ${s}`);switch(s[0]){case"%":((null===r||void 0===r?void 0:r.emptyFields)||s.length>1)&&(e=e||[],e.push(s));break;case":":s.length>1&&(n=n||[],n.push(s));break;case"@":((null===r||void 0===r?void 0:r.emptyVar)||s.length>1)&&(i=i||[],i.push(s))}}return{f:e,t:n,v:i}}const yt={BlockHash:[32,[1,52]],OperationHash:[32,[5,116]],OperationListHash:[32,[133,233]],OperationListListHash:[32,[29,159,109]],ProtocolHash:[32,[2,170]],ContextHash:[32,[79,199]],ED25519PublicKeyHash:[20,[6,161,159]],SECP256K1PublicKeyHash:[20,[6,161,161]],P256PublicKeyHash:[20,[6,161,164]],ContractHash:[20,[2,90,121]],CryptoboxPublicKeyHash:[16,[153,103]],ED25519Seed:[32,[13,15,58,7]],ED25519PublicKey:[32,[13,15,37,217]],SECP256K1SecretKey:[32,[17,162,224,201]],P256SecretKey:[32,[16,81,238,189]],ED25519EncryptedSeed:[56,[7,90,60,179,41]],SECP256K1EncryptedSecretKey:[56,[9,237,241,174,150]],P256EncryptedSecretKey:[56,[9,48,57,115,171]],SECP256K1PublicKey:[33,[3,254,226,86]],P256PublicKey:[33,[3,178,139,127]],SECP256K1Scalar:[33,[38,248,136]],SECP256K1Element:[33,[5,92,0]],ED25519SecretKey:[64,[43,246,78,7]],ED25519Signature:[64,[9,245,205,134,18]],SECP256K1Signature:[64,[13,115,101,19,63]],P256Signature:[64,[54,240,44,52]],GenericSignature:[64,[4,130,43]],ChainID:[4,[87,82,0]]};function bt(t,...r){const e=tt(t);for(const n of r){const[t,r]=yt[n];if(e.length===t+r.length){let t=0;for(;t<r.length&&e[t]===r[t];)t++;if(t===r.length)return[n,e.slice(r.length)]}}return null}function Et(t,r){const[e,n]=yt[t];if(r.length!==e)throw new at(`Incorrect data length for ${t}: ${r.length}`);return rt([...n,...r])}function vt(t,r){const e=r,n=Array.isArray(e)?e:e.args;if(2===n.length){return"pair"===t?{prim:"pair",args:n}:{prim:"Pair",args:n}}return Object.assign(Object.assign({},Array.isArray(e)?{prim:t}:e),{args:[n[0],{prim:t,args:n.slice(1)}]})}function Pt(t){return Array.isArray(t)||"pair"===t.prim}function At(t){return Array.isArray(t)||"prim"in t&&"Pair"===t.prim}const St=/^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])[T ]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|[+-]([01][0-9]|2[0-3]):([0-5][0-9]))$/;function Tt(t){if("string"in t){if(ht(t.string))return new Date(parseInt(t.string,10));if(St.test(t.string)){const r=new Date(t.string);if(!Number.isNaN(r.valueOf))return r}}else if(mt(t.int))return new Date(parseInt(t.int,10));return null}function It(t){return t.map((t=>(t>>4&15).toString(16)+(15&t).toString(16))).join("")}const _t={ABS:!0,ADD:!0,ADDRESS:!0,AMOUNT:!0,AND:!0,APPLY:!0,BALANCE:!0,BLAKE2B:!0,CAR:!0,CDR:!0,CHAIN_ID:!0,CHECK_SIGNATURE:!0,COMPARE:!0,CONCAT:!0,CONS:!0,EDIV:!0,EQ:!0,EXEC:!0,FAILWITH:!0,GE:!0,GET_AND_UPDATE:!0,GT:!0,HASH_KEY:!0,IMPLICIT_ACCOUNT:!0,INT:!0,ISNAT:!0,JOIN_TICKETS:!0,KECCAK:!0,LE:!0,LEVEL:!0,LSL:!0,LSR:!0,LT:!0,MEM:!0,MUL:!0,NEG:!0,NEQ:!0,NEVER:!0,NOT:!0,NOW:!0,OR:!0,PACK:!0,PAIRING_CHECK:!0,READ_TICKET:!0,SAPLING_VERIFY_UPDATE:!0,SELF:!0,SELF_ADDRESS:!0,SENDER:!0,SET_DELEGATE:!0,SHA256:!0,SHA3:!0,SHA512:!0,SIZE:!0,SLICE:!0,SOME:!0,SOURCE:!0,SPLIT_TICKET:!0,SUB:!0,SWAP:!0,TICKET:!0,TOTAL_VOTING_POWER:!0,TRANSFER_TOKENS:!0,UNIT:!0,VOTING_POWER:!0,XOR:!0,RENAME:!0,OPEN_CHEST:!0,SUB_MUTEZ:!0},xt=Object.assign({},_t,{CONTRACT:!0,CREATE_CONTRACT:!0,DIG:!0,DIP:!0,DROP:!0,DUG:!0,DUP:!0,EMPTY_BIG_MAP:!0,EMPTY_MAP:!0,EMPTY_SET:!0,GET:!0,IF:!0,IF_CONS:!0,IF_LEFT:!0,IF_NONE:!0,ITER:!0,LAMBDA:!0,LEFT:!0,LOOP:!0,LOOP_LEFT:!0,MAP:!0,NIL:!0,NONE:!0,PAIR:!0,PUSH:!0,RIGHT:!0,SAPLING_EMPTY_STATE:!0,UNPACK:!0,UNPAIR:!0,UPDATE:!0,CAST:!0,VIEW:!0}),Ot={unit:!0,never:!0,bool:!0,int:!0,nat:!0,string:!0,chain_id:!0,bytes:!0,mutez:!0,key_hash:!0,key:!0,signature:!0,timestamp:!0,address:!0},Ct=Object.assign({},Ot,{or:!0,pair:!0,set:!0,big_map:!0,contract:!0,lambda:!0,list:!0,map:!0,operation:!0,option:!0,bls12_381_g1:!0,bls12_381_g2:!0,bls12_381_fr:!0,sapling_transaction:!0,sapling_state:!0,ticket:!0,chest_key:!0,chest:!0});class Nt extends lt{constructor(t,r){super(t,r),this.val=t,Object.setPrototypeOf(this,Nt.prototype)}}function $t(t){return"prim"in t}function Rt(t){if($t(t))return!0;throw new Nt(t,"prim expression expected")}function Dt(t){if(Array.isArray(t))return!0;throw new Nt(t,"sequence expression expected")}function Lt(t){if(function(t){return Array.isArray(t)||"prim"in t}(t))return!0;throw new Nt(t,"prim or sequence expression expected")}function kt(t){if("-"===t.int[0])throw new Nt(t,"natural number expected")}function Ut(t){if("int"in t)return!0;throw new Nt(t,"int literal expected")}function Mt(t){if("string"in t)return!0;throw new Nt(t,"string literal expected")}function Kt(t,r){var e;if(0===r&&void 0===t.args||(null===(e=t.args)||void 0===e?void 0:e.length)===r)return!0;throw new Nt(t,`${r} arguments expected`)}function Ft(t){var r,e;if(Array.isArray(t)){for(const r of t){if(!Array.isArray(r)&&!$t(r))throw new Nt(t,"sequence or prim expected");Ft(r)}return!0}if(Rt(t)){if(Object.prototype.hasOwnProperty.call(_t,t.prim))return Kt(t,0),!0;switch(t.prim){case"DROP":case"PAIR":case"UNPAIR":case"DUP":case"UPDATE":case"GET":void 0!==t.args&&Kt(t,1)&&Ut(t.args[0])&&kt(t.args[0]);break;case"DIG":case"DUG":case"SAPLING_EMPTY_STATE":Kt(t,1)&&Ut(t.args[0])&&kt(t.args[0]);break;case"NONE":case"LEFT":case"RIGHT":case"NIL":case"CAST":Kt(t,1)&&Wt(t.args[0]);break;case"UNPACK":Kt(t,1)&&Bt(t.args[0]);break;case"CONTRACT":Kt(t,1)&&jt(t.args[0]);break;case"IF_NONE":case"IF_LEFT":case"IF_CONS":case"IF":Kt(t,2)&&(Dt(t.args[0])&&Ft(t.args[0]),Dt(t.args[1])&&Ft(t.args[1]));break;case"MAP":case"ITER":case"LOOP":case"LOOP_LEFT":Kt(t,1)&&Ft(t.args[0]);break;case"CREATE_CONTRACT":Kt(t,1)&&Zt(t.args[0]);break;case"DIP":if(2===(null===(r=t.args)||void 0===r?void 0:r.length))Ut(t.args[0])&&kt(t.args[0]),Dt(t.args[1])&&Ft(t.args[1]);else{if(1!==(null===(e=t.args)||void 0===e?void 0:e.length))throw new Nt(t,"1 or 2 arguments expected");Dt(t.args[0])&&Ft(t.args[0])}break;case"PUSH":Kt(t,2)&&(Gt(t.args[0]),Qt(t.args[1]));break;case"EMPTY_SET":Kt(t,1)&&Ht(t.args[0]);break;case"EMPTY_MAP":Kt(t,2)&&(Ht(t.args[0]),Wt(t.args[1]));break;case"EMPTY_BIG_MAP":Kt(t,2)&&(Ht(t.args[0]),Vt(t.args[1]));break;case"LAMBDA":Kt(t,3)&&(Wt(t.args[0]),Wt(t.args[1]),Dt(t.args[2])&&Ft(t.args[2]));break;case"VIEW":Kt(t,2)&&(Mt(t.args[0])&&Yt(t.args[0]),Wt(t.args[1])&&Gt(t.args[1]));break;default:throw new Nt(t,"instruction expected")}}return!0}function Ht(t){if(Lt(t))if(Array.isArray(t)||"pair"===t.prim||"or"===t.prim||"option"===t.prim)qt(t,(t=>Ht(t)));else if(!Object.prototype.hasOwnProperty.call(Ot,t.prim))throw new Nt(t,`${t.prim}: type is not comparable`);return!0}function Bt(t){if(Lt(t)&&$t(t)){if(!Object.prototype.hasOwnProperty.call(Ct,t.prim)||"big_map"===t.prim||"operation"===t.prim||"sapling_state"===t.prim||"ticket"===t.prim)throw new Nt(t,`${t.prim}: type can't be used inside PACK/UNPACK instructions`);qt(t,(t=>Bt(t)))}return!0}function Gt(t){if(Lt(t)&&$t(t)){if(!Object.prototype.hasOwnProperty.call(Ct,t.prim)||"big_map"===t.prim||"operation"===t.prim||"sapling_state"===t.prim||"ticket"===t.prim||"contract"===t.prim)throw new Nt(t,`${t.prim}: type can't be pushed`);qt(t,(t=>Gt(t)))}return!0}function Jt(t){if(Lt(t)&&$t(t)){if(!Object.prototype.hasOwnProperty.call(Ct,t.prim)||"operation"===t.prim||"contract"===t.prim)throw new Nt(t,`${t.prim}: type can't be used as part of a storage`);qt(t,(t=>Jt(t)))}return!0}function jt(t){if(Lt(t)&&$t(t)){if(!Object.prototype.hasOwnProperty.call(Ct,t.prim)||"operation"===t.prim)throw new Nt(t,`${t.prim}: type can't be used as part of a parameter`);qt(t,(t=>jt(t)))}return!0}function Vt(t){if(Lt(t)&&$t(t)){if(!Object.prototype.hasOwnProperty.call(Ct,t.prim)||"big_map"===t.prim||"operation"===t.prim||"sapling_state"===t.prim)throw new Nt(t,`${t.prim}: type can't be used inside a big_map`);qt(t,(t=>Vt(t)))}return!0}const zt=new RegExp("^[a-zA-Z0-9_.%@]*$");function Yt(t){if(t.string.length>31)throw new Nt(t,`view name too long: ${t.string}`);if(!zt.test(t.string))throw new Nt(t,`invalid character(s) in view name: ${t.string}`)}function Wt(t){if(Lt(t)&&$t(t)){if(!Object.prototype.hasOwnProperty.call(Ct,t.prim))throw new Nt(t,"type expected");qt(t,(t=>Wt(t)))}return!0}function qt(t,r){if(Array.isArray(t)||"pair"===t.prim){const e=Array.isArray(t)?t:t.args;if(void 0===e||e.length<2)throw new Nt(t,"at least 2 arguments expected");return e.forEach((t=>{Lt(t)&&r(t)})),!0}switch(t.prim){case"option":case"list":Kt(t,1)&&Lt(t.args[0])&&r(t.args[0]);break;case"contract":Kt(t,1)&&jt(t.args[0]);break;case"or":Kt(t,2)&&Lt(t.args[0])&&Lt(t.args[1])&&(r(t.args[0]),r(t.args[1]));break;case"lambda":Kt(t,2)&&(Wt(t.args[0]),Wt(t.args[1]));break;case"set":Kt(t,1)&&Ht(t.args[0]);break;case"map":Kt(t,2)&&Lt(t.args[0])&&Lt(t.args[1])&&(Ht(t.args[0]),r(t.args[1]));break;case"big_map":Kt(t,2)&&Lt(t.args[0])&&Lt(t.args[1])&&(Ht(t.args[0]),Vt(t.args[1]),r(t.args[1]));break;case"ticket":Kt(t,1)&&Lt(t.args[0])&&Ht(t.args[0]);break;case"sapling_state":case"sapling_transaction":Kt(t,1)&&Ut(t.args[0]);break;default:Kt(t,0)}return!0}function Qt(t){if("int"in t||"string"in t||"bytes"in t)return!0;if(Array.isArray(t)){let r=0;for(const e of t)$t(e)&&"Elt"===e.prim?(Kt(e,2)&&(Qt(e.args[0]),Qt(e.args[1])),r++):Qt(e);if(0!==r&&r!==t.length)throw new Nt(t,"data entries and map elements can't be intermixed");return!0}if(!$t(t))throw new Nt(t,"data entry expected");switch(t.prim){case"Unit":case"True":case"False":case"None":Kt(t,0);break;case"Pair":if(void 0===t.args||t.args.length<2)throw new Nt(t,"at least 2 arguments expected");for(const r of t.args)Qt(r);break;case"Left":case"Right":case"Some":Kt(t,1)&&Qt(t.args[0]);break;default:if(!Object.prototype.hasOwnProperty.call(xt,t.prim))throw new Nt(t,"data entry or instruction expected");Ft(t)}return!0}function Zt(t){if(Dt(t)){const r={},e={};for(const n of t)if(Rt(n)){if("view"!==n.prim){if(n.prim in r)throw new Nt(t,`duplicate contract section: ${n.prim}`);r[n.prim]=!0}switch(n.prim){case"code":Kt(n,1)&&Dt(n.args[0])&&Ft(n.args[0]);break;case"parameter":Kt(n,1)&&jt(n.args[0]);break;case"storage":Kt(n,1)&&Jt(n.args[0]);break;case"view":if(Kt(n,4)){if(Mt(n.args[0])){const r=n.args[0];if(r.string in e)throw new Nt(t,`duplicate view name: ${r.string}`);e[r.string]=!0,Yt(r)}Gt(n.args[1]),Gt(n.args[2]),Dt(n.args[3])&&Ft(n.args[3])}break;default:throw new Nt(t,`unexpected contract section: ${n.prim}`)}}}return!0}function Xt(t){try{return Zt(t),!0}catch(r){return!1}}function tr(t){try{return Qt(t),!0}catch(r){return!1}}function rr(t){try{return Ft(t),!0}catch(r){return!1}}function er(t){try{return Wt(t),!0}catch(r){return!1}}function nr(t){return Object.prototype.hasOwnProperty.call(xt,t.prim)}function ir(t){if(!Array.isArray(t))return!1;for(const r of t)if("prim"in r){if(nr(r))throw new lt(t,`Instruction outside of a lambda: ${JSON.stringify(t)}`);if("Elt"===r.prim)throw new lt(t,`Elt item outside of a map literal: ${JSON.stringify(t)}`)}return!0}const sr=["parameter","storage","code","False","Elt","Left","None","Pair","Right","Some","True","Unit","PACK","UNPACK","BLAKE2B","SHA256","SHA512","ABS","ADD","AMOUNT","AND","BALANCE","CAR","CDR","CHECK_SIGNATURE","COMPARE","CONCAT","CONS","CREATE_ACCOUNT","CREATE_CONTRACT","IMPLICIT_ACCOUNT","DIP","DROP","DUP","EDIV","EMPTY_MAP","EMPTY_SET","EQ","EXEC","FAILWITH","GE","GET","GT","HASH_KEY","IF","IF_CONS","IF_LEFT","IF_NONE","INT","LAMBDA","LE","LEFT","LOOP","LSL","LSR","LT","MAP","MEM","MUL","NEG","NEQ","NIL","NONE","NOT","NOW","OR","PAIR","PUSH","RIGHT","SIZE","SOME","SOURCE","SENDER","SELF","STEPS_TO_QUOTA","SUB","SWAP","TRANSFER_TOKENS","SET_DELEGATE","UNIT","UPDATE","XOR","ITER","LOOP_LEFT","ADDRESS","CONTRACT","ISNAT","CAST","RENAME","bool","contract","int","key","key_hash","lambda","list","map","big_map","nat","option","or","pair","set","signature","string","bytes","mutez","timestamp","unit","operation","address","SLICE","DIG","DUG","EMPTY_BIG_MAP","APPLY","chain_id","CHAIN_ID","LEVEL","SELF_ADDRESS","never","NEVER","UNPAIR","VOTING_POWER","TOTAL_VOTING_POWER","KECCAK","SHA3","PAIRING_CHECK","bls12_381_g1","bls12_381_g2","bls12_381_fr","sapling_state","sapling_transaction","SAPLING_EMPTY_STATE","SAPLING_VERIFY_UPDATE","ticket","TICKET","READ_TICKET","SPLIT_TICKET","JOIN_TICKETS","GET_AND_UPDATE","chest","chest_key","OPEN_CHEST","VIEW","view","constant","SUB_MUTEZ"],ar=Object.assign({},...sr.map(((t,r)=>({[t]:r}))));var or;!function(t){t[t.Int=0]="Int",t[t.String=1]="String",t[t.Sequence=2]="Sequence",t[t.Prim0=3]="Prim0",t[t.Prim0Annot=4]="Prim0Annot",t[t.Prim1=5]="Prim1",t[t.Prim1Annot=6]="Prim1Annot",t[t.Prim2=7]="Prim2",t[t.Prim2Annot=8]="Prim2Annot",t[t.Prim=9]="Prim",t[t.Bytes=10]="Bytes"}(or||(or={}));class cr{constructor(){this.buffer=[]}get length(){return this.buffer.length}writeBytes(t){this.buffer.push(...t.map((t=>255&t)))}writeUint8(t){const r=0|t;this.buffer.push(255&r)}writeUint16(t){const r=0|t;this.buffer.push(r>>8&255),this.buffer.push(255&r)}writeUint32(t){const r=0|t;this.buffer.push(r>>24&255),this.buffer.push(r>>16&255),this.buffer.push(r>>8&255),this.buffer.push(255&r)}writeInt8(t){this.writeUint8(t)}writeInt16(t){this.writeUint16(t)}writeInt32(t){this.writeUint32(t)}}const lr=new Error("bounds out of range");class ur{constructor(t,r=0,e=t.length){this.buffer=t,this.idx=r,this.cap=e}get length(){return this.cap-this.idx}readBytes(t){if(this.cap-this.idx<t)throw lr;const r=this.buffer.slice(this.idx,this.idx+t);return this.idx+=t,r}reader(t){if(this.cap-this.idx<t)throw lr;const r=new ur(this.buffer,this.idx,this.idx+t);return this.idx+=t,r}copy(){return new ur(this.buffer,this.idx,this.cap)}readUint8(){if(this.cap-this.idx<1)throw lr;return this.buffer[this.idx++]>>>0}readUint16(){if(this.cap-this.idx<2)throw lr;return(this.buffer[this.idx++]<<8|this.buffer[this.idx++])>>>0}readUint32(){if(this.cap-this.idx<4)throw lr;return(this.buffer[this.idx++]<<24|this.buffer[this.idx++]<<16|this.buffer[this.idx++]<<8|this.buffer[this.idx++])>>>0}readInt8(){if(this.cap-this.idx<1)throw lr;return this.buffer[this.idx++]<<24>>24}readInt16(){if(this.cap-this.idx<2)throw lr;return(this.buffer[this.idx++]<<8|this.buffer[this.idx++])<<16>>16}readInt32(){if(this.cap-this.idx<4)throw lr;return this.buffer[this.idx++]<<24|this.buffer[this.idx++]<<16|this.buffer[this.idx++]<<8|this.buffer[this.idx++]}}var pr,fr,gr;function mr(t){let r;const e=t.readUint8();switch(e){case fr.ED25519:r="ED25519PublicKeyHash";break;case fr.SECP256K1:r="SECP256K1PublicKeyHash";break;case fr.P256:r="P256PublicKeyHash";break;default:throw new Error(`unknown public key hash tag: ${e}`)}return{type:r,hash:t.readBytes(20)}}function hr(t){let r;const e=t.readUint8();switch(e){case pr.Implicit:r=mr(t);break;case pr.Originated:r={type:"ContractHash",hash:t.readBytes(20)},t.readBytes(1);break;default:throw new Error(`unknown address tag: ${e}`)}if(0!==t.length){const e=new TextDecoder;r.entryPoint=e.decode(new Uint8Array(t.readBytes(t.length)))}return r}function dr(t,r){let e;switch(t.type){case"ED25519PublicKeyHash":e=fr.ED25519;break;case"SECP256K1PublicKeyHash":e=fr.SECP256K1;break;case"P256PublicKeyHash":e=fr.P256;break;default:throw new Error(`unexpected address type: ${t.type}`)}r.writeUint8(e),r.writeBytes(Array.from(t.hash))}function wr(t){let r,e;const n=t.readUint8();switch(n){case gr.ED25519:e="ED25519PublicKey",r=32;break;case gr.SECP256K1:e="SECP256K1PublicKey",r=33;break;case gr.P256:e="P256PublicKey",r=33;break;default:throw new Error(`unknown public key tag: ${n}`)}return{type:e,publicKey:t.readBytes(r)}}function yr(t,r,e){var n,i;const[s,a]=e(t);if(Array.isArray(s)){const t=new cr;for(const r of s){const e=a.next();if(e.done)throw new Error("REPORT ME: iterator is done");yr(r,t,e.value)}return r.writeUint8(or.Sequence),r.writeUint32(t.length),void r.writeBytes(t.buffer)}if("string"in s){const t=(new TextEncoder).encode(s.string);return r.writeUint8(or.String),r.writeUint32(t.length),void r.writeBytes(Array.from(t))}if("int"in s){r.writeUint8(or.Int);let t=BigInt(s.int);const e=t<0;e&&(t=-t);let n=0;do{const i=0===n?BigInt(6):BigInt(7);let s=t&(BigInt(1)<<i)-BigInt(1);t>>=i,t&&(s|=BigInt(128)),0===n&&e&&(s|=BigInt(64)),r.writeUint8(Number(s)),n++}while(t);return}if("bytes"in s){const t=function(t){const r=[];for(let e=0;e<t.length;e+=2){const n=t.slice(e,e+2),i=parseInt(n,16);if(Number.isNaN(i))throw new ct(n);r.push(i)}return r}(s.bytes);return r.writeUint8(or.Bytes),r.writeUint32(t.length),void r.writeBytes(t)}const o=ar[s.prim];if(void 0===o)throw new TypeError(`Can't encode primary: ${s.prim}`);const c=((null===(n=s.args)||void 0===n?void 0:n.length)||0)<3?or.Prim0+2*((null===(i=s.args)||void 0===i?void 0:i.length)||0)+(void 0===s.annots||0===s.annots.length?0:1):or.Prim;if(r.writeUint8(c),r.writeUint8(o),void 0!==s.args)if(s.args.length<3)for(const l of s.args){const t=a.next();if(t.done)throw new Error("REPORT ME: iterator is done");yr(l,r,t.value)}else{const t=new cr;for(const r of s.args){const e=a.next();if(e.done)throw new Error("REPORT ME: iterator is done");yr(r,t,e.value)}r.writeUint32(t.length),r.writeBytes(t.buffer)}if(void 0!==s.annots&&0!==s.annots.length){const t=(new TextEncoder).encode(s.annots.join(" "));r.writeUint32(t.length),r.writeBytes(Array.from(t))}else void 0!==s.args&&s.args.length>=3&&r.writeUint32(0)}function br(t,r){function*e(){for(;;)yield xr}const[n,i]=r,s=t.readUint8();switch(s){case or.Int:{const r=[];let e;do{e=t.readInt8(),r.push(e)}while(0!==(128&e));let n=BigInt(0),s=!1;for(let t=r.length-1;t>=0;t--){const e=0===t?BigInt(6):BigInt(7),i=BigInt(r[t]);n<<=e,n|=i&(BigInt(1)<<e)-BigInt(1),0===t&&(s=!!(i&BigInt(64)))}return s&&(n=-n),i({int:String(n)})}case or.String:{const r=t.readUint32(),e=t.readBytes(r);return i({string:(new TextDecoder).decode(new Uint8Array(e))})}case or.Bytes:{const r=t.readUint32(),e=t.readBytes(r);return i({bytes:It(Array.from(e))})}case or.Sequence:{const r=t.readUint32();let s=[],a=t.copy(),o=e();for(let e=0;e<2;e++){const e=a.reader(r);for(s=[];e.length>0;){const t=o.next();if(t.done)throw new Error("REPORT ME: iterator is done");s.push(br(e,t.value))}o=n(s),a=t}return i(s)}default:{if(s>9)throw new Error(`Unknown tag: ${s}`);const r=t.readUint8();if(r>=sr.length)throw new Error(`Unknown primitive tag: ${r}`);const a=sr[r],o=s-3>>1;let c={prim:a},l=e(),u=t.copy();for(let e=0;e<2;e++){if(c={prim:a},o<3)for(let t=0;t<o;t++){const t=l.next();if(t.done)throw new Error("REPORT ME: iterator is done");c.args=c.args||[],c.args.push(br(u,t.value))}else{c.args=c.args||[];const t=u.readUint32(),r=u.reader(t);for(;r.length>0;){const t=l.next();if(t.done)throw new Error("REPORT ME: iterator is done");c.args.push(br(r,t.value))}}l=n(c),u=t}if(1===(s-3&1)||3===o){const r=t.readUint32();if(0!==r){const e=t.readBytes(r),n=new TextDecoder;c.annots=n.decode(new Uint8Array(e)).split(" ")}}return i(c)}}}!function(t){t[t.Implicit=0]="Implicit",t[t.Originated=1]="Originated"}(pr||(pr={})),function(t){t[t.ED25519=0]="ED25519",t[t.SECP256K1=1]="SECP256K1",t[t.P256=2]="P256"}(fr||(fr={})),function(t){t[t.ED25519=0]="ED25519",t[t.SECP256K1=1]="SECP256K1",t[t.P256=2]="P256"}(gr||(gr={}));const Er=t=>"prim"in t&&("Left"===t.prim||"Right"===t.prim),vr=t=>"prim"in t&&("Some"===t.prim||"None"===t.prim),Pr=t=>{if(Pt(t))return r=>{if(!At(r))throw new pt(t,r,`pair expected: ${JSON.stringify(r)}`);ir(r);const e=vt("pair",t);return[vt("Pair",r),function*(){for(const t of e.args)yield Pr(t)}()]};switch(t.prim){case"or":return r=>{if(!Er(r))throw new pt(t,r,`or expected: ${JSON.stringify(r)}`);return[r,function*(){yield Pr(t.args["Left"===r.prim?0:1])}()]};case"option":return r=>{if(!vr(r))throw new pt(t,r,`option expected: ${JSON.stringify(r)}`);return[r,function*(){"Some"===r.prim&&(yield Pr(t.args[0]))}()]};case"list":case"set":return r=>{if(!Array.isArray(r))throw new pt(t,r,`${t.prim} expected: ${JSON.stringify(r)}`);return[r,function*(){for(const e of r)yield Pr(t.args[0])}()]};case"map":return r=>{if(!Array.isArray(r))throw new pt(t,r,`map expected: ${JSON.stringify(r)}`);return[r,function*(){for(const e of r)yield r=>{if(!("prim"in r)||"Elt"!==r.prim)throw new pt(t,r,`map element expected: ${JSON.stringify(r)}`);return[r,function*(){for(const r of t.args)yield Pr(r)}()]}}()]};case"chain_id":return r=>{if(!("bytes"in r)&&!("string"in r))throw new pt(t,r,`chain id expected: ${JSON.stringify(r)}`);let e;if("string"in r){const n=bt(r.string,"ChainID");if(null===n)throw new pt(t,r,`chain id base58 expected: ${r.string}`);e={bytes:It(n[1])}}else e=r;return[e,[][Symbol.iterator]()]};case"signature":return r=>{if(!("bytes"in r)&&!("string"in r))throw new pt(t,r,`signature expected: ${JSON.stringify(r)}`);let e;if("string"in r){const n=bt(r.string,"ED25519Signature","SECP256K1Signature","P256Signature","GenericSignature");if(null===n)throw new pt(t,r,`signature base58 expected: ${r.string}`);e={bytes:It(n[1])}}else e=r;return[e,[][Symbol.iterator]()]};case"key_hash":return r=>{if(!("bytes"in r)&&!("string"in r))throw new pt(t,r,`key hash expected: ${JSON.stringify(r)}`);let e;if("string"in r){const n=bt(r.string,"ED25519PublicKeyHash","SECP256K1PublicKeyHash","P256PublicKeyHash");if(null===n)throw new pt(t,r,`key hash base58 expected: ${r.string}`);const i=new cr;dr({type:n[0],hash:n[1]},i),e={bytes:It(i.buffer)}}else e=r;return[e,[][Symbol.iterator]()]};case"key":return r=>{if(!("bytes"in r)&&!("string"in r))throw new pt(t,r,`public key expected: ${JSON.stringify(r)}`);let e;if("string"in r){const n=bt(r.string,"ED25519PublicKey","SECP256K1PublicKey","P256PublicKey");if(null===n)throw new pt(t,r,`public key base58 expected: ${r.string}`);const i=new cr;!function(t,r){let e;switch(t.type){case"ED25519PublicKey":e=gr.ED25519;break;case"SECP256K1PublicKey":e=gr.SECP256K1;break;case"P256PublicKey":e=gr.P256;break;default:throw new Error(`unexpected public key type: ${t.type}`)}r.writeUint8(e),r.writeBytes(Array.from(t.publicKey))}({type:n[0],publicKey:n[1]},i),e={bytes:It(i.buffer)}}else e=r;return[e,[][Symbol.iterator]()]};case"address":return r=>{if(!("bytes"in r)&&!("string"in r))throw new pt(t,r,`address expected: ${JSON.stringify(r)}`);let e;if("string"in r){const n=r.string.split("%"),i=bt(n[0],"ED25519PublicKeyHash","SECP256K1PublicKeyHash","P256PublicKeyHash","ContractHash");if(null===i)throw new pt(t,r,`address base58 expected: ${r.string}`);const s=new cr;!function(t,r){if("ContractHash"===t.type?(r.writeUint8(pr.Originated),r.writeBytes(Array.from(t.hash)),r.writeUint8(0)):(r.writeUint8(pr.Implicit),dr(t,r)),void 0!==t.entryPoint&&""!==t.entryPoint&&"default"!==t.entryPoint){const e=(new TextEncoder).encode(t.entryPoint);r.writeBytes(Array.from(e))}}({type:i[0],hash:i[1],entryPoint:n.length>1?n[1]:void 0},s),e={bytes:It(s.buffer)}}else e=r;return[e,[][Symbol.iterator]()]};case"timestamp":return r=>{if(!("string"in r)&&!("int"in r))throw new pt(t,r,`timestamp expected: ${JSON.stringify(r)}`);let e;if("string"in r){const n=Tt(r);if(null===n)throw new pt(t,r,`can't parse date: ${r.string}`);e={int:String(Math.floor(n.getTime()/1e3))}}else e=r;return[e,[][Symbol.iterator]()]};default:return Sr}},Ar=t=>"prim"in t&&"PUSH"===t.prim,Sr=t=>Ar(t)?(Ft(t),[t,function*(){yield Sr,yield Pr(t.args[0])}()]):[t,function*(){for(;;)yield Sr}()];function Tr(t,r){const e=new cr;return e.writeUint8(5),yr(t,e,void 0!==r?Pr(r):Sr),e.buffer}function Ir(t,r){return{bytes:It(Tr(t,r))}}const _r=t=>{if(Pt(t)){const r=Array.isArray(t)?t:t.args;return[e=>{if(!At(e))throw new pt(t,e,`pair expected: ${JSON.stringify(e)}`);return function*(){for(const t of r)yield _r(t)}()},t=>t]}switch(t.prim){case"or":return[r=>{if(!Er(r))throw new pt(t,r,`or expected: ${JSON.stringify(r)}`);return function*(){yield _r(t.args["Left"===r.prim?0:1])}()},t=>t];case"option":return[r=>{if(!vr(r))throw new pt(t,r,`option expected: ${JSON.stringify(r)}`);return function*(){"Some"===r.prim&&(yield _r(t.args[0]))}()},t=>t];case"list":case"set":return[r=>{if(!Array.isArray(r))throw new pt(t,r,`${t.prim} expected: ${JSON.stringify(r)}`);return function*(){for(;;)yield _r(t.args[0])}()},t=>t];case"map":return[r=>{if(!Array.isArray(r))throw new pt(t,r,`map expected: ${JSON.stringify(r)}`);return function*(){for(;;)yield[r=>{if(!("prim"in r)||"Elt"!==r.prim)throw new pt(t,r,`map element expected: ${JSON.stringify(r)}`);return function*(){for(const r of t.args)yield _r(r)}()},t=>t]}()},t=>t];case"chain_id":return[()=>[][Symbol.iterator](),r=>{if(!("bytes"in r)&&!("string"in r))throw new pt(t,r,`chain id expected: ${JSON.stringify(r)}`);if("string"in r)return r;const e=gt(r.bytes);if(null===e)throw new pt(t,r,`can't parse bytes: ${r.bytes}`);return{string:Et("ChainID",e)}}];case"signature":return[()=>[][Symbol.iterator](),r=>{if(!("bytes"in r)&&!("string"in r))throw new pt(t,r,`signature expected: ${JSON.stringify(r)}`);if("string"in r)return r;const e=gt(r.bytes);if(null===e)throw new pt(t,r,`can't parse bytes: ${r.bytes}`);return{string:Et("GenericSignature",e)}}];case"key_hash":return[()=>[][Symbol.iterator](),r=>{if(!("bytes"in r)&&!("string"in r))throw new pt(t,r,`key hash expected: ${JSON.stringify(r)}`);if("string"in r)return r;const e=gt(r.bytes);if(null===e)throw new pt(t,r,`can't parse bytes: ${r.bytes}`);const n=mr(new ur(new Uint8Array(e)));return{string:Et(n.type,n.hash)+(n.entryPoint?"%"+n.entryPoint:"")}}];case"key":return[()=>[][Symbol.iterator](),r=>{if(!("bytes"in r)&&!("string"in r))throw new pt(t,r,`public key expected: ${JSON.stringify(r)}`);if("string"in r)return r;const e=gt(r.bytes);if(null===e)throw new pt(t,r,`can't parse bytes: ${r.bytes}`);const n=wr(new ur(new Uint8Array(e)));return{string:Et(n.type,n.publicKey)}}];case"address":return[()=>[][Symbol.iterator](),r=>{if(!("bytes"in r)&&!("string"in r))throw new pt(t,r,`address expected: ${JSON.stringify(r)}`);if("string"in r)return r;const e=gt(r.bytes);if(null===e)throw new pt(t,r,`can't parse bytes: ${r.bytes}`);const n=hr(new ur(new Uint8Array(e)));return{string:Et(n.type,n.hash)+(n.entryPoint?"%"+n.entryPoint:"")}}];case"timestamp":return[()=>[][Symbol.iterator](),r=>{if(!("int"in r)&&!("string"in r))throw new pt(t,r,`address expected: ${JSON.stringify(r)}`);if("string"in r)return r;return{string:new Date(1e3*parseInt(r.int,10)).toISOString().slice(0,19)+"Z"}}];default:return xr}},xr=[t=>Ar(t)?(Ft(t),function*(){yield xr,yield _r(t.args[0])}()):function*(){for(;;)yield xr}(),t=>t];function Or(t,r){const e=new ur(t);if(5!==e.readUint8())throw new Error("incorrect packed data magic number");const n=br(e,void 0!==r?_r(r):xr);if(Qt(n))return n;throw new Error}function Cr(t,r){const e=gt(t.bytes);if(null===e)throw new Error(`can't parse bytes: "${t.bytes}"`);return Or(e,r)}function Nr(t){const r=gt(t.bytes);if(null===r)throw new Error(`can't parse bytes: "${t.bytes}"`);return hr(new ur(new Uint8Array(r)))}function $r(t){const r=gt(t.bytes);if(null===r)throw new Error(`can't parse bytes: "${t.bytes}"`);return mr(new ur(new Uint8Array(r)))}function Rr(t){const r=gt(t.bytes);if(null===r)throw new Error(`can't parse bytes: "${t.bytes}"`);return wr(new ur(new Uint8Array(r)))}class Dr extends lt{constructor(t,r,e){super(t,e),this.stackState=r,Object.setPrototypeOf(this,Dr.prototype)}}function Lr(t){return Array.isArray(t)?"pair":t.prim}function kr(t){return"prim"in t?t.args:t}function Ur(t,r,e=!1){if(Lr(t)!==Lr(r))throw new pt(t,void 0,`types mismatch: ${Lr(t)} != ${Lr(r)}`);const n=[wt(t),wt(r)];if(n[0].t&&n[1].t&&n[0].t[0]!==n[1].t[0])throw new pt(t,void 0,`${Lr(t)}: type names mismatch: ${n[0].t[0]} != ${n[1].t[0]}`);if(e&&n[0].f&&n[1].f&&n[0].f[0]!==n[1].f[0])throw new pt(t,void 0,`${Lr(t)}: field names mismatch: ${n[0].f[0]} != ${n[1].f}`);if(Pt(t)){const e=vt("pair",t),n=vt("pair",r);return Ur(e.args[0],n.args[0],!0),void Ur(e.args[1],n.args[1],!0)}switch(t.prim){case"option":case"list":case"contract":case"set":case"ticket":Ur(t.args[0],r.args[0]);break;case"or":Ur(t.args[0],r.args[0],!0),Ur(t.args[1],r.args[1],!0);break;case"lambda":case"map":case"big_map":Ur(t.args[0],r.args[0]),Ur(t.args[1],r.args[1]);break;case"sapling_state":case"sapling_transaction":if(parseInt(t.args[0].int,10)!==parseInt(r.args[0].int,10))throw new pt(t,void 0,`${Lr(t)}: type argument mismatch: ${t.args[0].int} != ${r.args[0].int}`)}}function Mr(t,r){if(t.length!==r.length)throw new pt(t,void 0,`stack length mismatch: ${t.length} != ${r.length}`);for(let e=0;e<t.length;e++)Ur(t[e],r[e])}function Kr(t,r=!1){var e,n,i;if(!Array.isArray(t)){const s=wt(t);if(((null===(e=s.t)||void 0===e?void 0:e.length)||0)>1)throw new pt(t,void 0,`${t.prim}: at most one type annotation allowed: ${t.annots}`);if(r){if(((null===(n=s.f)||void 0===n?void 0:n.length)||0)>1)throw new pt(t,void 0,`${t.prim}: at most one field annotation allowed: ${t.annots}`)}else if(((null===(i=s.f)||void 0===i?void 0:i.length)||0)>0)throw new pt(t,void 0,`${t.prim}: field annotations aren't allowed: ${t.annots}`)}if(Pt(t)){const r=kr(t);for(const t of r)Kr(t,!0)}else switch(t.prim){case"option":case"list":case"contract":case"set":Kr(t.args[0]);break;case"or":for(const r of t.args)Kr(r,!0);break;case"lambda":case"map":case"big_map":Kr(t.args[0]),Kr(t.args[1])}}function Fr(t){if(!Array.isArray(t))return!1;for(const r of t)if(!(Array.isArray(r)&&Fr(r)||"prim"in r&&nr(r)))return!1;return!0}function Hr(t,r,e){if(Pt(r)){if(At(t)){ir(t);const n=vt("Pair",t),i=vt("pair",r);return Hr(n.args[0],i.args[0],e),void Hr(n.args[1],i.args[1],e)}throw new pt(r,t,`pair expected: ${JSON.stringify(t)}`)}switch(r.prim){case"int":if("int"in t&&mt(t.int))return;throw new pt(r,t,`integer value expected: ${JSON.stringify(t)}`);case"nat":case"mutez":if("int"in t&&ht(t.int))return;throw new pt(r,t,`natural value expected: ${JSON.stringify(t)}`);case"string":if("string"in t)return;throw new pt(r,t,`string value expected: ${JSON.stringify(t)}`);case"bytes":case"bls12_381_g1":case"bls12_381_g2":if("bytes"in t&&null!==gt(t.bytes))return;throw new pt(r,t,`bytes value expected: ${JSON.stringify(t)}`);case"bool":if("prim"in t&&("True"===t.prim||"False"===t.prim))return;throw new pt(r,t,`boolean value expected: ${JSON.stringify(t)}`);case"key_hash":if("string"in t&&null!==bt(t.string,"ED25519PublicKeyHash","SECP256K1PublicKeyHash","P256PublicKeyHash"))return;if("bytes"in t)try{return void $r(t)}catch(n){}throw new pt(r,t,`key hash expected: ${JSON.stringify(t)}`);case"timestamp":if(("string"in t||"int"in t)&&null!==Tt(t))return;throw new pt(r,t,`timestamp expected: ${JSON.stringify(t)}`);case"address":if("string"in t){let r=t.string;const e=t.string.indexOf("%");if(e>=0&&(r=t.string.slice(0,e)),null!==bt(r,"ED25519PublicKeyHash","SECP256K1PublicKeyHash","P256PublicKeyHash","ContractHash"))return}else if("bytes"in t)try{return void Nr(t)}catch(n){}throw new pt(r,t,`address expected: ${JSON.stringify(t)}`);case"key":if("string"in t&&null!==bt(t.string,"ED25519PublicKey","SECP256K1PublicKey","P256PublicKey"))return;if("bytes"in t)try{return void Rr(t)}catch(n){}throw new pt(r,t,`public key expected: ${JSON.stringify(t)}`);case"unit":if("prim"in t&&"Unit"===t.prim)return;throw new pt(r,t,`unit value expected: ${JSON.stringify(t)}`);case"signature":if("bytes"in t||"string"in t&&null!==bt(t.string,"ED25519Signature","SECP256K1Signature","P256Signature","GenericSignature"))return;throw new pt(r,t,`signature expected: ${JSON.stringify(t)}`);case"chain_id":if("bytes"in t||"string"in t){if(null!==("string"in t?tt(t.string):gt(t.bytes)))return}throw new pt(r,t,`chain id expected: ${JSON.stringify(t)}`);case"option":if("prim"in t){if("None"===t.prim)return;if("Some"===t.prim)return void Hr(t.args[0],r.args[0],e)}throw new pt(r,t,`option expected: ${JSON.stringify(t)}`);case"list":case"set":if(ir(t)){for(const n of t)Hr(n,r.args[0],e);return}throw new pt(r,t,`${r.prim} expected: ${JSON.stringify(t)}`);case"or":if("prim"in t){if("Left"===t.prim)return void Hr(t.args[0],r.args[0],e);if("Right"===t.prim)return void Hr(t.args[0],r.args[1],e)}throw new pt(r,t,`union (or) expected: ${JSON.stringify(t)}`);case"lambda":if(Fr(t)){const n=Br(t,[r.args[0]],e);if("failed"in n)throw new pt(r,t,`function is failed with error type: ${n.failed}`);if(1!==n.length)throw new pt(r,t,"function must return a value");return void Ur(r.args[1],n[0])}throw new pt(r,t,`function expected: ${JSON.stringify(t)}`);case"map":case"big_map":if(Array.isArray(t)){for(const n of t){if(!("prim"in n)||"Elt"!==n.prim)throw new pt(r,t,`map elements expected: ${JSON.stringify(t)}`);Hr(n.args[0],r.args[0],e),Hr(n.args[1],r.args[1],e)}return}throw new pt(r,t,`${r.prim} expected: ${JSON.stringify(t)}`);case"bls12_381_fr":if("int"in t&&mt(t.int)||"bytes"in t&&null!==gt(t.bytes))return;throw new pt(r,t,`BLS12-381 element expected: ${JSON.stringify(t)}`);case"sapling_state":if(Array.isArray(t))return;throw new pt(r,t,`sapling state expected: ${JSON.stringify(t)}`);case"ticket":return void Hr(t,{prim:"pair",args:[{prim:"address"},r.args[0],{prim:"nat"}]},e);default:throw new pt(r,t,`type ${Lr(r)} don't have Michelson literal representation`)}}function Br(t,r,e){const n=(null===e||void 0===e?void 0:e.protocol)||m;if(Array.isArray(t))return function(t,r,e){let n=r,i=r,s=0;for(const a of t){const t=Br(a,i,e);if(n=t,"failed"in t)break;i=t,s++}if("failed"in n&&0==n.level&&(!("prim"in n.failed)||"never"!==n.failed.prim)&&s!==t.length-1)throw new Dr(t,n,"FAIL must appear in a tail position");if(void 0!==(null===e||void 0===e?void 0:e.traceCallback)){const i={op:t,in:r,out:n};e.traceCallback(i)}return"failed"in n?{failed:n.failed,level:n.level+1}:n}(t,r,e);const i=t;function s(t,...e){if(r.length<e.length+t)throw new Dr(i,r,`${i.prim}: stack must have at least ${e.length} element(s)`);let n=t;for(const s of e){if(null!==s&&0!==s.length){let t=0;for(;t<s.length&&s[t]!==Lr(r[n]);)t++;if(t===s.length)throw new Dr(i,r,`${i.prim}: stack type mismatch: [${n}] expected to be ${s}, got ${Lr(r[n])} instead`)}n++}return r.slice(t,e.length+t)}function a(t){return(...e)=>{try{return t(...e)}catch(n){throw n instanceof lt?new Dr(i,r,n.message):n}}}function o(t){return e=>{try{return t(e)}catch(n){throw n instanceof lt?new Dr(i,r,n.message):n}}}const c=a(wt),l=a(Mr),u=a(Ur),p=o(Ht),h=o(Bt),d=o(Jt),y=o(Gt),b=o(Vt);function E(t,e){const n=c(i,Object.assign(Object.assign({},e),{emptyFields:void 0!==t.f&&t.f>1,emptyVar:void 0!==t.v&&t.v>1})),s=(t,e,n)=>{if(t&&t.length>(e||0))throw new Dr(i,r,`${i.prim}: at most ${e||0} ${n} annotations allowed`)};return s(n.f,t.f,"field"),s(n.t,t.t,"type"),s(n.v,t.v,"variable"),n}function v(t,r){const e=t,n=Array.isArray(e)?{prim:"pair",args:e}:e,i=c(n),s=void 0!==r.v||void 0!==r.t||void 0!==r.f?[...(null===r.v?i.v:r.v)||[],...(null===r.t?i.t:r.t)||[],...(null===r.f?i.f:r.f)||[]]:void 0,a=function(t,r){var e={};for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&r.indexOf(n)<0&&(e[n]=t[n]);if(null!=t&&"function"===typeof Object.getOwnPropertySymbols){var i=0;for(n=Object.getOwnPropertySymbols(t);i<n.length;i++)r.indexOf(n[i])<0&&Object.prototype.propertyIsEnumerable.call(t,n[i])&&(e[n[i]]=t[n[i]])}return e}(n,["annots"]);return Object.assign(Object.assign({},a),s&&0!==s.length&&{annots:s})}function P(t,r){const e=E({v:1});return v(t,{v:void 0!==e.v?e.v:void 0!==r?[r]:null,t:null})}function A(t,e,n,s,a){var o,l,u,p;const f=null===(o=c(e).f)||void 0===o?void 0:o[0],g=null===(l=n.f)||void 0===l?void 0:l[s];if(void 0!==g&&"%"!==g&&void 0!==f&&g!==f)throw new Dr(i,r,`${i.prim}: field names doesn't match: ${g} !== ${f}`);const m=null===(u=n.v)||void 0===u?void 0:u[s],h=null===(p=c(t).v)||void 0===p?void 0:p[0];return v(e,{t:null,v:m?"@%"===m?f?["@"+f.slice(1)]:void 0:"@%%"===m?h?["@"+h.slice(1)+"."+(f?f.slice(1):a)]:f?["@"+f.slice(1)]:void 0:[m]:null})}function S(t,e,n=e){const s=vt("pair",t);if(1===n)return[s.args[0]];if(2===n)return s.args;const a=s.args[1];if(Pt(a))return[s.args[0],...S(a,e,n-1)];throw new Dr(i,r,`${i.prim}: at least ${e} fields are expected`)}function T(t,e,n=e){if(0===n)return t;const s=vt("pair",t);if(1===n)return s.args[0];const a=s.args[1];if(Pt(a))return T(a,e,n-2);if(2===n)return a;throw new Dr(i,r,`${i.prim}: at least ${e+1} fields are expected`)}function I(t,e,n,s=n){if(0===s)return e;const a=vt("pair",t);if(1===s)return Object.assign(Object.assign({},a),{args:[e,a.args[1]]});const o=a.args[1];if(Pt(o))return Object.assign(Object.assign({},a),{args:[a.args[0],I(o,e,n,s-2)]});if(2===s)return Object.assign(Object.assign({},a),{args:[a.args[0],e]});throw new Dr(i,r,`${i.prim}: at least ${n+1} fields are expected`)}const _=(t,r)=>["@"+(t.v?t.v[0].slice(1)+".":"")+r];function x(t,r){return"failed"in t||"failed"in r?"failed"in t?r:t:(l(t,r),t)}const O=(t=>{var i,a,o,m,O;switch(t.prim){case"DUP":{const e=t.args?parseInt(t.args[0].int,10):1;if(0===e)throw new Dr(t,r,"DUP 0 is forbidden");const n=s(e-1,null)[0];if("ticket"===Lr(n))throw new Dr(t,r,"ticket can't be DUPed");return[n,...r]}case"SWAP":{const t=s(0,null,null);return E({}),[t[1],t[0],...r.slice(2)]}case"SOME":return[v({prim:"option",args:[s(0,null)[0]]},E({t:1,v:1})),...r.slice(1)];case"UNIT":return[v({prim:"unit"},E({v:1,t:1})),...r];case"PAIR":{const e=t.args?parseInt(t.args[0].int,10):2;if(e<2)throw new Dr(t,r,`PAIR ${e} is forbidden`);const n=s(0,...new Array(e).fill(null)),i=E({f:e,t:1,v:1},{specialFields:!0}),a=t=>{const r=t.lastIndexOf(".");return t.slice(r>0?r+1:1)},o=n.map(((t,r)=>{var e;const n=c(t);return v(t,{v:null,t:null,f:i.f&&i.f.length>r&&"%"!==i.f[r]?"%@"===i.f[r]?n.v?["%"+a((null===(e=n.v)||void 0===e?void 0:e[0])||"")]:void 0:[i.f[r]]:void 0})}));return[v({prim:"pair",args:o},{t:i.t,v:i.v}),...r.slice(e)]}case"UNPAIR":{const e=t.args?parseInt(t.args[0].int,10):2;if(e<2)throw new Dr(t,r,`UNPAIR ${e} is forbidden`);const n=s(0,["pair"])[0],i=E({f:2,v:2},{specialVar:!0});return[...S(n,e).map(((t,r)=>A(n,t,i,r,0===r?"car":"cdr"))),...r.slice(1)]}case"CAR":case"CDR":{const e=vt("pair",s(0,["pair"])[0]);return[A(e,e.args["CAR"===t.prim?0:1],E({f:1,v:1},{specialVar:!0}),0,t.prim.toLocaleLowerCase()),...r.slice(1)]}case"CONS":{const t=s(0,null,["list"]);return u(t[0],t[1].args[0]),[P({prim:"list",args:[t[1].args[0]]}),...r.slice(2)]}case"SIZE":return s(0,["string","list","set","map","bytes"]),[P({prim:"nat"}),...r.slice(1)];case"MEM":{const t=s(0,null,["set","map","big_map"]);return p(t[0]),u(t[0],t[1].args[0]),[P({prim:"bool"}),...r.slice(2)]}case"GET":if(t.args){const e=parseInt(t.args[0].int,10);return[P(T(s(0,["pair"])[0],e)),...r.slice(1)]}{const t=s(0,null,["map","big_map"]);return p(t[0]),u(t[0],t[1].args[0]),[P({prim:"option",args:[t[1].args[1]]}),...r.slice(2)]}case"UPDATE":if(t.args){const e=parseInt(t.args[0].int,10),n=s(0,null,["pair"]);return[P(I(n[1],n[0],e)),...r.slice(2)]}{const t=s(0,null,["bool","option"]);if(p(t[0]),"bool"===t[1].prim){const e=s(2,["set"]);return u(t[0],e[0].args[0]),[P({prim:"set",args:[v(t[0],{t:null})]}),...r.slice(3)]}const e=s(2,["map","big_map"]);return u(t[0],e[0].args[0]),"map"===e[0].prim?[P({prim:"map",args:[v(t[0],{t:null}),v(t[1].args[0],{t:null})]}),...r.slice(3)]:(b(t[1].args[0]),[P({prim:"big_map",args:[v(t[0],{t:null}),v(t[1].args[0],{t:null})]}),...r.slice(3)])}case"GET_AND_UPDATE":{const t=E({v:2}),e=s(0,null,["option"],["map","big_map"]);p(e[0]),u(e[0],e[2].args[0]),u(e[1].args[0],e[2].args[1]);const n=null===(i=t.v)||void 0===i?void 0:i.map((t=>"@"!==t?[t]:void 0));return"map"===e[2].prim?[v({prim:"option",args:[e[2].args[1]]},{v:null===n||void 0===n?void 0:n[0]}),v({prim:"map",args:[v(e[0],{t:null}),v(e[1].args[0],{t:null})]},{v:null===n||void 0===n?void 0:n[1]}),...r.slice(3)]:(b(e[1].args[0]),[v({prim:"option",args:[e[2].args[1]]},{v:null===n||void 0===n?void 0:n[0]}),v({prim:"big_map",args:[v(e[0],{t:null}),v(e[1].args[0],{t:null})]},{v:null===n||void 0===n?void 0:n[1]}),...r.slice(3)])}case"EXEC":{const t=s(0,null,["lambda"]);return u(t[0],t[1].args[0]),[P(t[1].args[1]),...r.slice(2)]}case"APPLY":{const e=s(0,null,["lambda"]);if(d(e[0]),y(e[0]),!Pt(e[1].args[0]))throw new Dr(t,r,`${t.prim}: function's argument must be a pair: ${Lr(e[1].args[0])}`);const n=e[1].args[0];return u(e[0],kr(n)[0]),[P({prim:"lambda",args:[kr(n)[1],e[1].args[1]]}),...r.slice(2)]}case"FAILWITH":{const t=s(0,null)[0];return w(n,g.PtEdo2Zk)||h(t),{failed:t,level:0}}case"NEVER":return s(0,["never"]),{failed:{prim:"never"},level:0};case"RENAME":return[P(s(0,null)[0]),...r.slice(1)];case"CONCAT":{const e=s(0,["string","list","bytes"]);if("list"===e[0].prim){if("string"!==Lr(e[0].args[0])&&"bytes"!==Lr(e[0].args[0]))throw new Dr(t,r,`${t.prim}: can't concatenate list of ${Lr(e[0].args[0])}'s`);return[P(e[0].args[0]),...r.slice(1)]}const n=s(1,["string","bytes"]);if(e[0].prim!==n[0].prim)throw new Dr(t,r,`${t.prim}: can't concatenate ${e[0].prim} with ${n[0].prim}`);return[P(n[0]),...r.slice(2)]}case"SLICE":return[P({prim:"option",args:[s(0,["nat"],["nat"],["string","bytes"])[2]]},"@slice"),...r.slice(3)];case"PACK":{const t=s(0,null)[0];return h(t),[P({prim:"bytes"},"@packed"),...r.slice(1)]}case"ADD":{const e=s(0,["nat","int","timestamp","mutez","bls12_381_g1","bls12_381_g2","bls12_381_fr"],["nat","int","timestamp","mutez","bls12_381_g1","bls12_381_g2","bls12_381_fr"]);if("nat"===e[0].prim&&"int"===e[1].prim||"int"===e[0].prim&&"nat"===e[1].prim)return[P({prim:"int"}),...r.slice(2)];if("int"===e[0].prim&&"timestamp"===e[1].prim||"timestamp"===e[0].prim&&"int"===e[1].prim)return[P({prim:"timestamp"}),...r.slice(2)];if(("int"===e[0].prim||"nat"===e[0].prim||"mutez"===e[0].prim||"bls12_381_g1"===e[0].prim||"bls12_381_g2"===e[0].prim||"bls12_381_fr"===e[0].prim)&&e[0].prim===e[1].prim)return[P(e[0]),...r.slice(2)];throw new Dr(t,r,`${t.prim}: can't add ${e[0].prim} to ${e[1].prim}`)}case"SUB":{const e=w(n,g.PsiThaCa)?s(0,["nat","int","timestamp","mutez"],["nat","int","timestamp","mutez"]):s(0,["nat","int","timestamp"],["nat","int","timestamp"]);if(("nat"===e[0].prim||"int"===e[0].prim)&&("nat"===e[1].prim||"int"===e[1].prim)||"timestamp"===e[0].prim&&"timestamp"===e[1].prim)return[P({prim:"int"}),...r.slice(2)];if("timestamp"===e[0].prim&&"int"===e[1].prim)return[P({prim:"timestamp"}),...r.slice(2)];if("mutez"===e[0].prim&&"mutez"===e[1].prim)return[P({prim:"mutez"}),...r.slice(2)];throw new Dr(t,r,`${t.prim}: can't subtract ${e[0].prim} from ${e[1].prim}`)}case"SUB_MUTEZ":return s(0,["mutez"],["mutez"]),[P({prim:"option",args:[{prim:"mutez"}]}),...r.slice(2)];case"MUL":{const e=s(0,["nat","int","mutez","bls12_381_g1","bls12_381_g2","bls12_381_fr"],["nat","int","mutez","bls12_381_g1","bls12_381_g2","bls12_381_fr"]);if("nat"===e[0].prim&&"int"===e[1].prim||"int"===e[0].prim&&"nat"===e[1].prim)return[P({prim:"int"}),...r.slice(2)];if("nat"===e[0].prim&&"mutez"===e[1].prim||"mutez"===e[0].prim&&"nat"===e[1].prim)return[P({prim:"mutez"}),...r.slice(2)];if(("bls12_381_g1"===e[0].prim||"bls12_381_g2"===e[0].prim||"bls12_381_fr"===e[0].prim)&&"bls12_381_fr"===e[1].prim||("nat"===e[0].prim||"int"===e[0].prim)&&e[0].prim===e[1].prim)return[P(e[0]),...r.slice(2)];if(("nat"===e[0].prim||"int"===e[0].prim)&&"bls12_381_fr"===e[1].prim||("nat"===e[1].prim||"int"===e[1].prim)&&"bls12_381_fr"===e[0].prim)return[P({prim:"bls12_381_fr"}),...r.slice(2)];throw new Dr(t,r,`${t.prim}: can't multiply ${e[0].prim} by ${e[1].prim}`)}case"EDIV":{const e=(t,r)=>({prim:"option",args:[{prim:"pair",args:[{prim:t},{prim:r}]}]}),n=s(0,["nat","int","mutez"],["nat","int","mutez"]);if("nat"===n[0].prim&&"nat"===n[1].prim)return[P(e("nat","nat")),...r.slice(2)];if(!("nat"!==n[0].prim&&"int"!==n[0].prim||"nat"!==n[1].prim&&"int"!==n[1].prim))return[P(e("int","nat")),...r.slice(2)];if("mutez"===n[0].prim&&"nat"===n[1].prim)return[P(e("mutez","mutez")),...r.slice(2)];if("mutez"===n[0].prim&&"mutez"===n[1].prim)return[P(e("nat","mutez")),...r.slice(2)];throw new Dr(t,r,`${t.prim}: can't euclideally divide ${n[0].prim} by ${n[1].prim}`)}case"ABS":return s(0,["int"]),[P({prim:"nat"}),...r.slice(1)];case"ISNAT":return s(0,["int"]),[P({prim:"option",args:[{prim:"nat"}]}),...r.slice(1)];case"INT":return s(0,["nat","bls12_381_fr"]),[P({prim:"int"}),...r.slice(1)];case"NEG":{const t=s(0,["nat","int","bls12_381_g1","bls12_381_g2","bls12_381_fr"])[0];return"nat"===t.prim||"int"===t.prim?[P({prim:"int"}),...r.slice(1)]:[P(t),...r.slice(1)]}case"LSL":case"LSR":return s(0,["nat"],["nat"]),[P({prim:"nat"}),...r.slice(2)];case"OR":case"XOR":{const e=s(0,["nat","bool"],["nat","bool"]);if(e[0].prim!==e[1].prim)throw new Dr(t,r,`${t.prim}: both arguments must be of the same type: ${e[0].prim}, ${e[1].prim}`);return[P(e[1]),...r.slice(2)]}case"AND":{const e=s(0,["nat","bool","int"],["nat","bool"]);if(("int"!==e[0].prim||"nat"!==e[1].prim)&&e[0].prim!==e[1].prim)throw new Dr(t,r,`${t.prim}: both arguments must be of the same type: ${e[0].prim}, ${e[1].prim}`);return[P(e[1]),...r.slice(2)]}case"NOT":return"bool"===s(0,["nat","bool","int"])[0].prim?[P({prim:"bool"}),...r.slice(1)]:[P({prim:"int"}),...r.slice(1)];case"COMPARE":{const t=s(0,null,null);return p(t[0]),p(t[1]),[P({prim:"int"}),...r.slice(2)]}case"EQ":case"NEQ":case"LT":case"GT":case"LE":case"GE":return s(0,["int"]),[P({prim:"bool"}),...r.slice(1)];case"SELF":{if(void 0===(null===e||void 0===e?void 0:e.contract))throw new Dr(t,r,`${t.prim}: contract required`);const n=E({f:1,v:1}),i=Vr(e.contract,null===(a=n.f)||void 0===a?void 0:a[0]);if(null===i)throw new Dr(t,r,`${t.prim}: contract has no entrypoint ${i}`);return[v({prim:"contract",args:[i]},{v:n.v?n.v:["@self"]}),...r]}case"TRANSFER_TOKENS":{const t=s(0,null,["mutez"],["contract"]);return u(t[0],t[2].args[0]),[P({prim:"operation"}),...r.slice(3)]}case"SET_DELEGATE":{const e=s(0,["option"])[0];if("key_hash"!==Lr(e.args[0]))throw new Dr(t,r,`${t.prim}: key hash expected: ${Lr(e.args[0])}`);return[P({prim:"operation"}),...r.slice(1)]}case"IMPLICIT_ACCOUNT":return s(0,["key_hash"]),[P({prim:"contract",args:[{prim:"unit"}]}),...r.slice(1)];case"NOW":return[P({prim:"timestamp"},"@now"),...r];case"AMOUNT":return[P({prim:"mutez"},"@amount"),...r];case"BALANCE":return[P({prim:"mutez"},"@balance"),...r];case"CHECK_SIGNATURE":return s(0,["key"],["signature"],["bytes"]),[P({prim:"bool"}),...r.slice(3)];case"BLAKE2B":case"SHA256":case"SHA512":case"KECCAK":case"SHA3":return s(0,["bytes"]),[P({prim:"bytes"}),...r.slice(1)];case"HASH_KEY":return s(0,["key"]),[P({prim:"key_hash"}),...r.slice(1)];case"SOURCE":return[P({prim:"address"},"@source"),...r];case"SENDER":return[P({prim:"address"},"@sender"),...r];case"ADDRESS":{const t=s(0,["contract"])[0],e=E({v:1});return[v({prim:"address",[f]:t},{v:e.v?e.v:_(c(t),"address")}),...r.slice(1)]}case"SELF_ADDRESS":{const t={prim:"address"};return void 0!==(null===e||void 0===e?void 0:e.contract)&&(t[f]={prim:"contract",args:[Gr(e.contract,"parameter").args[0]]}),[P(t,"@address"),...r]}case"CHAIN_ID":return[P({prim:"chain_id"}),...r];case"DROP":{E({});const e=void 0!==t.args?parseInt(t.args[0].int,10):1;return s(e-1,null),r.slice(e)}case"DIG":{E({});const e=parseInt(t.args[0].int,10);return[s(e,null)[0],...r.slice(0,e),...r.slice(e+1)]}case"DUG":{E({});const e=parseInt(t.args[0].int,10);return[...r.slice(1,e+1),s(0,null)[0],...r.slice(e+1)]}case"NONE":return Kr(t.args[0]),[v({prim:"option",args:[t.args[0]]},E({t:1,v:1})),...r];case"LEFT":case"RIGHT":{const e=s(0,null)[0],n=E({f:2,t:1,v:1},{specialFields:!0}),i=c(e),a=[v(e,{t:null,v:null,f:n.f&&n.f.length>0&&"%"!==n.f[0]?"%@"===n.f[0]?i.v?["%"+i.v[0].slice(1)]:void 0:n.f:void 0}),v(t.args[0],{t:null,f:n.f&&n.f.length>1&&"%"!==n.f[1]?n.f:void 0})];return[v({prim:"or",args:"LEFT"===t.prim?a:[a[1],a[0]]},{t:n.t,v:n.v}),...r.slice(1)]}case"NIL":return Kr(t.args[0]),[v({prim:"list",args:[t.args[0]]},E({t:1,v:1})),...r];case"UNPACK":return s(0,["bytes"]),Kr(t.args[0]),[P({prim:"option",args:[t.args[0]]},"@unpacked"),...r.slice(1)];case"CONTRACT":{const e=s(0,["address"])[0];Kr(t.args[0]);const n=E({v:1,f:1}),i=e[f];if(void 0!==i){const e=Vr(i,null===(o=n.f)||void 0===o?void 0:o[0]);if(null===e)throw new Dr(t,r,`${t.prim}: contract has no entrypoint ${e}`);u(e,t.args[0])}return[v({prim:"option",args:[{prim:"contract",args:[t.args[0]]}]},{v:n.v?n.v:_(c(e),"contract")}),...r.slice(1)]}case"CAST":{E({});const e=s(0,null)[0];return Kr(t.args[0]),u(t.args[0],e),[t.args[0],...r.slice(1)]}case"IF_NONE":{E({});const n=s(0,["option"])[0],i=r.slice(1);return x(Br(t.args[0],i,e),Br(t.args[1],[v(n.args[0],{t:null,v:_(c(n),"some")}),...i],e))}case"IF_LEFT":{E({});const n=s(0,["or"])[0],i=c(n),a=c(n.args[0]),o=c(n.args[1]),l=r.slice(1);return x(Br(t.args[0],[v(n.args[0],{t:null,v:_(i,a.f?a.f[0].slice(1):"left")}),...l],e),Br(t.args[1],[v(n.args[1],{t:null,v:_(i,o.f?o.f[0].slice(1):"right")}),...l],e))}case"IF_CONS":{E({});const n=s(0,["list"])[0],i=c(n),a=r.slice(1);return x(Br(t.args[0],[v(n.args[0],{t:null,v:_(i,"hd")}),v(n,{t:null,v:_(i,"tl")}),...a],e),Br(t.args[1],a,e))}case"IF":{E({}),s(0,["bool"]);const n=r.slice(1);return x(Br(t.args[0],n,e),Br(t.args[1],n,e))}case"MAP":{const n=s(0,["list","map","option"])[0],i=r.slice(1),a="map"===n.prim?{prim:"pair",args:n.args}:n.args[0],o=Br(t.args[0],[v(a,{t:null,v:_(c(n),"elt")}),...i],e);if("failed"in o){if(!("prim"in o.failed)||"never"!==o.failed.prim)throw new Dr(t,r,`${t.prim}: FAIL is not allowed in MAP`);return{failed:o.failed,level:o.level+1}}if(o.length<1)throw new Dr(t,r,`${t.prim}: function must return a value`);return l(o.slice(1),i),"list"===n.prim?[P({prim:"list",args:[o[0]]}),...i]:"map"===n.prim?[P({prim:"map",args:[n.args[0],o[0]]}),...i]:[P({prim:"option",args:[o[0]]}),...i]}case"ITER":{E({});const n=s(0,["set","list","map"])[0],i=r.slice(1),a="map"===n.prim?{prim:"pair",args:n.args}:n.args[0],o=Br(t.args[0],[v(a,{t:null,v:_(c(n),"elt")}),...i],e);return"failed"in o?{failed:o.failed,level:o.level+1}:(l(o,i),i)}case"LOOP":{E({}),s(0,["bool"]);const n=r.slice(1),i=Br(t.args[0],n,e);return"failed"in i?{failed:i.failed,level:i.level+1}:(l(i,[{prim:"bool"},...n]),n)}case"LOOP_LEFT":{E({});const n=s(0,["or"])[0],i=r.slice(1),a=Br(t.args[0],[v(n.args[0],{t:null,v:_(c(n),"left")}),...i],e);return"failed"in a?{failed:a.failed,level:a.level+1}:(l(a,[n,...i]),[v(n.args[1],{t:null,v:E({v:1}).v}),...i])}case"DIP":{E({});const n=2===t.args.length?parseInt(t.args[0].int,10):1;s(n-1,null);const i=r.slice(0,n),a=r.slice(n),o=2===t.args.length?Br(t.args[1],a,e):Br(t.args[0],a,e);return"failed"in o?{failed:o.failed,level:o.level+1}:[...i,...o]}case"CREATE_CONTRACT":{const e=E({v:2}),n=s(0,["option"],["mutez"],null);if("key_hash"!==Lr(n[0].args[0]))throw new Dr(t,r,`${t.prim}: key hash expected: ${Lr(n[0].args[0])}`);d(n[2])&&(Yr(t.args[0]),Ur(Gr(t.args[0],"storage").args[0],n[2]));const i=null===(m=e.v)||void 0===m?void 0:m.map((t=>"@"!==t?[t]:void 0));return[v({prim:"operation"},{v:null===i||void 0===i?void 0:i[0]}),v({prim:"address",[f]:{prim:"contract",args:[Gr(t.args[0],"parameter").args[0]]}},{v:null===i||void 0===i?void 0:i[1]}),...r.slice(3)]}case"PUSH":return Kr(t.args[0]),Hr(t.args[1],t.args[0],Object.assign(Object.assign({},e),{contract:void 0})),[P(t.args[0]),...r];case"EMPTY_SET":return Kr(t.args[0]),p(t.args[0]),[v({prim:"set",args:t.args},E({t:1,v:1})),...r];case"EMPTY_MAP":return Kr(t.args[0]),p(t.args[0]),Kr(t.args[1]),[v({prim:"map",args:t.args},E({t:1,v:1})),...r];case"EMPTY_BIG_MAP":return Kr(t.args[0]),p(t.args[0]),Kr(t.args[1]),b(t.args[0]),[v({prim:"big_map",args:t.args},E({t:1,v:1})),...r];case"LAMBDA":{Kr(t.args[0]),Kr(t.args[1]);const n=Br(t.args[2],[t.args[0]],Object.assign(Object.assign({},e),{contract:void 0}));if("failed"in n)return{failed:n.failed,level:n.level+1};if(1!==n.length)throw new Dr(t,r,`${t.prim}: function must return a value`);return u(t.args[1],n[0]),[P({prim:"lambda",args:[t.args[0],t.args[1]]}),...r]}case"LEVEL":return[P({prim:"nat"},"@level"),...r];case"TOTAL_VOTING_POWER":return[P({prim:"nat"}),...r];case"VOTING_POWER":return s(0,["key_hash"]),[P({prim:"nat"}),...r.slice(1)];case"TICKET":{const t=s(0,null,["nat"])[0];return p(t),[v({prim:"ticket",args:[t]},E({t:1,v:1})),...r.slice(2)]}case"JOIN_TICKETS":{const e=vt("pair",s(0,["pair"])[0]);if("ticket"!==Lr(e.args[0]))throw new Dr(t,r,`${t.prim}: ticket expected: ${Lr(e.args[0])}`);return u(e.args[0],e.args[1]),[P({prim:"option",args:[v(e.args[0],{t:null})]}),...r.slice(1)]}case"SPLIT_TICKET":{const e=s(0,["ticket"],["pair"]),n=vt("pair",e[1]);if("nat"!==Lr(n.args[0]))throw new Dr(t,r,`${t.prim}: nat expected: ${Lr(n.args[0])}`);return u(n.args[0],n.args[1]),[P({prim:"option",args:[{prim:"pair",args:[v(e[0],{t:null}),v(e[0],{t:null})]}]}),...r.slice(2)]}case"READ_TICKET":{const t=E({v:2}),e=s(0,["ticket"])[0],n=null===(O=t.v)||void 0===O?void 0:O.map((t=>"@"!==t?[t]:void 0));return[v({prim:"pair",args:[{prim:"address"},v(e.args[0],{t:null}),{prim:"nat"}]},{v:null===n||void 0===n?void 0:n[0]}),v(e,{v:null===n||void 0===n?void 0:n[1],t:null}),...r.slice(1)]}case"PAIRING_CHECK":{const e=s(0,["list"])[0].args[0];if(!Pt(e))throw new Dr(t,r,`${t.prim}: pair expected: ${Lr(e)}`);const n=vt("pair",e);if("bls12_381_g1"!==Lr(n.args[0]))throw new Dr(t,r,`${t.prim}: bls12_381_g1 expected: ${Lr(n.args[0])}`);if("bls12_381_g2"!==Lr(n.args[1]))throw new Dr(t,r,`${t.prim}: bls12_381_g2 expected: ${Lr(n.args[1])}`);return[P({prim:"bool"}),...r.slice(1)]}case"SAPLING_EMPTY_STATE":return[v({prim:"sapling_state",args:[t.args[0]]},E({v:1,t:1})),...r];case"SAPLING_VERIFY_UPDATE":{const e=s(0,["sapling_transaction"],["sapling_state"]);if(parseInt(e[0].args[0].int,10)!==parseInt(e[1].args[0].int,10))throw new Dr(t,r,`${t.prim}: sapling memo size mismatch: ${e[0].args[0].int} != ${e[1].args[0].int}`);return w(n,g.PtJakarta)?[P({prim:"option",args:[{prim:"pair",args:[{prim:"int"},v(e[1],{t:null})]}]}),...r.slice(2)]:[P({prim:"option",args:[{prim:"pair",args:[{prim:"bytes"},{prim:"pair",args:[{prim:"int"},v(e[1],{t:null})]}]}]}),...r.slice(2)]}case"OPEN_CHEST":return s(0,["chest_key"],["chest"],["nat"]),[P({prim:"or",args:[{prim:"bytes"},{prim:"bool"}]}),...r.slice(3)];case"VIEW":{const e=s(0,null,["address"]);return y(e[0]),[P({prim:"option",args:[t.args[1]]}),...r.slice(2)]}default:throw new lt(t,`unexpected instruction: ${t.prim}`)}})(i);if(void 0!==(null===e||void 0===e?void 0:e.traceCallback)){const t={op:i,in:r,out:O};e.traceCallback(t)}return O}function Gr(t,r){for(const e of t)if(e.prim===r)return e;throw new lt(t,`missing contract section: ${r}`)}function Jr(t){const r={};for(const e of t)"view"===e.prim&&(r[e.args[0].string]=e);return r}function jr(t){if(Array.isArray(t))for(const r of t)if("prim"in r&&("parameter"===r.prim||"storage"===r.prim||"code"===r.prim))return!0;return!1}function Vr(t,r){r=r||"%default";const e=zr(t).find((t=>t[0]===r));return void 0!==e?e[1]:"%default"===r?jr(t)?Gr(t,"parameter").args[0]:t:null}function zr(t){if(jr(t)){const r=Gr(t,"parameter"),e=zr(r.args[0]),n=wt(r);return n.f?[[n.f[0],r.args[0]],...e]:e}if(r=t,Array.isArray(r)||"or"===r.prim){const r=kr(t),e=t=>{const e=wt(r[t]);if("or"===Lr(r[t])){const n=zr(r[t]);return e.f?[[e.f[0],r[t]],...n]:n}return e.f?[[e.f[0],r[t]]]:[]};return[...e(0),...e(1)]}var r;return[]}function Yr(t,r){const e=(e,n,i,s)=>{Kr(e,!0),Kr(n);const a=Br(s,[{prim:"pair",args:[Object.assign(Object.assign({},e),{annots:["@parameter"]}),Object.assign(Object.assign({},n),{annots:["@storage"]})]}],Object.assign(Object.assign({},r),{contract:t}));if("failed"in a)return a;try{Mr(a,[i])}catch(o){throw o instanceof lt?new Dr(s,a,o.message):o}return a},n=Gr(t,"parameter").args[0],i=Gr(t,"storage").args[0],s=e(n,i,{prim:"pair",args:[{prim:"list",args:[{prim:"operation"}]},i]},Gr(t,"code").args[0]);for(const a of Object.values(Jr(t)))e(a.args[1],i,a.args[2],a.args[3]);return s}function Wr(t,r,e){Kr(r),Hr(t,r,e||null)}function qr(t,r,e){for(const n of r)Kr(n);if(void 0!==(null===e||void 0===e?void 0:e.contract))for(const n of["parameter","storage"]){Kr(Gr(e.contract,n).args[0])}return Br(t,r,e||null)}function Qr(t,r,e=!1){if(Array.isArray(t)){for(const r of t)Kr(r);for(const t of r)Kr(t)}else Kr(t),Kr(r);Ur(t,r,e)}function Zr(t,r=!1){try{return Kr(t,r),!0}catch(e){return!1}}function Xr(t,r){try{return Yr(t,r)}catch(e){return null}}function te(t,r,e){try{return Wr(t,r,e),!0}catch(n){return!1}}function re(t,r,e=!1){try{return Qr(t,r,e),!0}catch(n){return!1}}class ee{constructor(t,r){this.contract=t,this.ctx=Object.assign({contract:t},r),this.output=Yr(t,this.ctx)}static parse(t,r){const e=new F(r),n="string"===typeof t?e.parseScript(t):e.parseJSON(t);if(null===n)throw new et("empty contract");if(Zt(n))return new ee(n,r)}static parseTypeExpression(t,r){const e=new F(r),n="string"===typeof t?e.parseScript(t):e.parseJSON(t);if(null===n)throw new nt("empty type expression");if(Wt(n)&&Kr(n))return n;throw void 0}static parseDataExpression(t,r){const e=new F(r),n="string"===typeof t?e.parseScript(t):e.parseJSON(t);if(null===n)throw new it("empty data expression");if(Qt(n))return n;throw void 0}section(t){return Gr(this.contract,t)}entryPoints(){return zr(this.contract)}entryPoint(t){return Vr(this.contract,t)}assertDataValid(t,r){Wr(t,r,this.ctx)}isDataValid(t,r){return te(t,r,this.ctx)}assertParameterValid(t,r){const e=this.entryPoint(t||void 0);if(null===e)throw new st(null===t||void 0===t?void 0:t.toString());this.assertDataValid(r,e)}isParameterValid(t,r){try{return this.assertParameterValid(t,r),!0}catch(e){return!1}}functionType(t,r){return qr(t,r,this.ctx)}}const ne=new ee([{prim:"parameter",args:[{prim:"unit"}]},{prim:"storage",args:[{prim:"unit"}]},{prim:"code",args:[[{prim:"CAR"},{prim:"NIL",args:[{prim:"operation"}]},{prim:"PAIR"}]]}]);function ie(t){return"failed"in t?`[FAILED: ${j(t.failed)}]`:t.map(((t,r)=>{const e=wt(t);return`[${r}${e.v?"/"+e.v[0]:""}]: ${j(t)}`})).join("\n")}function se(t,r){return e=>{var i;if(Array.isArray(e)&&!t)return;const s=null===(i=e.op[n])||void 0===i?void 0:i.macro,a=`${s?"Macro":"Op"}: ${s?j(s,void 0,!0)+" / ":""}${j(e.op)}\nInput:\n${ie(e.in)}\nOutput:\n${ie(e.out)}\n`;r(a)}}function ae(t){var r;if(t instanceof Dr){const e=null===(r=t.val[n])||void 0===r?void 0:r.macro;return`${e?"Macro":"Op"}: ${e?j(e,void 0,!0)+" / ":""}${j(t.val)}\nStack:\n${ie(t.stackState)}\n`}if(t instanceof pt){return`Type: ${Array.isArray(t.val)?"["+t.val.map(((t,r)=>`[${r}]: ${j(t)}`)).join("; ")+"]":j(t.val)}\n${t.data?`Data: ${j(t.data)}\n`:""}\n`}return`Value: ${j(t.val)}`}const oe={commitHash:"cbdd0af87e400489076259d065e2d328feb8e1b4",version:"12.1.0"}}}]);